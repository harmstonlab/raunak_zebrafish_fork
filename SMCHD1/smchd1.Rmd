---
title: "SMCHD1"
author: "Raunak Vijayakar"
date: "dd/mm/yyyy"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


### Raw counts and annotation
Starting with the txt output from featureCounts, you need to manually delete the first row (which contains command input information), and then the name of the first column (gene id). Then when you read the file as below, it will be correctly formatted.
```{r}
library(biomaRt)
library(DESeq2)
library(GenomicFeatures)

sm = read.delim("smchd1_counts copy.txt", sep = "")
sm = sm[,-c(1:5)] #remove unnecessary columns


#exclude any rows where no counts were found for any condition
sm = sm[rowSums(sm) > 0, ]

#take a look at the reads for each condition
barplot(colSums(sm), ylab="Number of aligned reads", las=2, cex.names=0.8)
#numbers are similar across all samples


#get matching annotations
dr.gtf.db <- makeTxDbFromGFF("Danio_rerio.GRCz11.104.chr.gtf", format="gtf")
ensembl.genes = genes(dr.gtf.db)
fish = useEnsembl(biomart="ENSEMBL_MART_ENSEMBL", host = "asia.ensembl.org", dataset="drerio_gene_ensembl", version = "104") #change host as needed
head(listAttributes(fish))#annotations we can request

bm.annotations = getBM(attributes=c("ensembl_gene_id", "entrezgene_id", "gene_biotype", "description", "zfin_id_symbol"), mart=fish, filters="ensembl_gene_id", values=ensembl.genes$gene_id, uniqueRows=TRUE) #error here sometimes, 104 db connection issue??
#also hgnc is so sparse that it could be dropped without consequence

ensembl.genes$zfin_id_symbol = bm.annotations$zfin_id_symbol[ match(ensembl.genes$gene_id, bm.annotations$ensembl_gene_id) ]
ensembl.genes$gene_biotype = bm.annotations$gene_biotype[ match(ensembl.genes$gene_id, bm.annotations$ensembl_gene_id) ]
ensembl.genes$status = bm.annotations$status[ match(ensembl.genes$gene_id, bm.annotations$ensembl_gene_id) ]
ensembl.genes$description = bm.annotations$description[ match(ensembl.genes$gene_id, bm.annotations$ensembl_gene_id) ]
ensembl.genes$entrezgene_id = bm.annotations$entrezgene_id[ match(ensembl.genes$gene_id, bm.annotations$ensembl_gene_id) ]


```




### DDS and Filtering

```{r}
#see how many reads are in rRNA/mtRNA
rrna = names(ensembl.genes[ensembl.genes$gene_biotype %in% c("Mt_rRNA", "rRNA" )])
total.rrna = colSums(sm[row.names(sm) %in% rrna,])
barplot(100 * (total.rrna / colSums(sm)), ylab="%rRNA/mtRNA", las=2, cex.names=0.8)

#how many reads are in mitochondrial chromosome?
chrM = names(ensembl.genes[ensembl.genes@seqnames %in% "MT", ])
total.mchrom = colSums(sm[row.names(sm) %in% chrM,])
barplot(100 * (total.mchrom / colSums(sm)), ylab="%MT", las=2, cex.names=0.8)


#remove rRNA and mtRNA
sm = sm[!(row.names(sm) %in% rrna),]
# #remove mitochondrial chromosome reads
# sm = sm[!(row.names(sm) %in% chrM),]


met = read.csv("smchd1_metadata.csv") #sample ids and conditions. no batch indicator, so we won't be controlling for that.

dds = DESeqDataSetFromMatrix(sm, met, ~ condition)

dds

dds <- estimateSizeFactors(dds)
dds <- estimateDispersions(dds) #this helps us deal w/fact that we don't have 30 samples/condition

#normalize for read depth
head(counts(dds))
head(counts(dds, normalized=TRUE)) #can do this because we called sizefactors b/f, these number can be compared directly, across condition, not across gene though

#only choosing genes that have a normalized mean expression across conditions >= 10. This removes lowly expressed genes that are hard to differentiate from noise. could also be done after examining p-value histogram of a significance test, comparing pre- and post-filtering.
filter = apply(counts(dds, normalized=TRUE), 1, function(x){ mean(x) >= 10 })
dds = dds[filter, ]
#20840 genes after filtering

#apply regularized log transform. 
rld <- rlog(dds)



```

Check for rRNA, and mt rRNA. Ideally these reads will be filtered out during the sequencing process (using ribozero, etc.). The barplots show that the sequencing is already well depleted for both of these sources of noise, as the percentages for both are low. Regardless, remove any genes annotated to be either rRNA, or mtRNA. Filter out genes that are lowly expressed (mean expression < 10), and apply a regularized log transform for PCA, normalizing for library size and putting the count data on a log2 scale.


### PCA
``` {r}
#do PCA
plotPCA(rld, intgroup = c( "condition"))
plotPCA(rld, intgroup = c( "sample_id"))


```


### Investigate SMCHD1 knockout [NOT RUN]
Look at expression levels for ENSDARG00000104374.
```{r, eval=F}

tmp = assay(rld)
tmp[row.names(tmp) == "ENSDARG00000104374"]


#calculate TPM
dr.exons = exonsBy(dr.gtf.db, "gene")
dr.exons = reduce(dr.exons) #we're not using ignore.strand here. why?
dr.lengths = sapply(dr.exons, function(x){sum(width(x))})

gene_lengths = dr.lengths / 1000
#normalize for gene length
rpk = sm / gene_lengths[row.names(sm)]
#normalize for read depth
ncscalingfactor = colSums(rpk) / 1e6
tpm = sweep(rpk, 2, ncscalingfactor, "/")

colSums(tpm)
#tpm tells you what proportion of reads (of the total reads per sample) mapped to a gene, so you can compare across samples by gene
#this is the most fitting measure for RNAseq
head(tpm)
#but this is ultimately an academic exercise, as we won't be inputting the tpms calculated here for deseq, we use rlog.
tpm[row.names(tpm) == "ENSDARG00000104374",]

```
The TPM calculations suggest that the mutated gene had reduction in mutants (especially smchd1) relative to DWT.

### Differential expression analysis
```{r}
#all_cond
#since condition is the only contrast, reduced model won't be controlling for sex, batch, etc.
nb = nbinomLRT(dds, full = design(dds), reduced = ~1)
all_cond = results(nb)
hist(all_cond$pvalue)
#though the listed foldchange is calculated for some pair of conditions, the p-value from nbinomlrt is for all conditions.

sum(is.na(all_cond$padj)) #191 genes have NA p-values and padj

###explanation from DESeq2 vignette:###
# If a row contains a sample with an extreme count outlier then the p value and adjusted p value will be set to NA. These outlier counts are detected by Cookâ€™s distance.

#For now I will remove these genes and move on, but they might deserve another look
all_cond = all_cond[!is.na(all_cond$padj),]

#significance level of 0.01 for FDR. this is a cutoff for the expected false positive rate (proportion of DEGs that were false to total DEGs). since we have a lot of genes, this seems like a reasonable alpha.
sum(all_cond$padj < 0.01)

#DM1_vs_DWT
DM1_vs_DWT = results(nb, contrast=c("condition", "DMUT1", "DWT"), independentFiltering = TRUE, alpha=0.1, test="Wald")
hist(DM1_vs_DWT$pvalue) #check this to ensure there isn't batch effect, and that we filtered out the low read genes. Though we can't control for batch in this case.
DM1_vs_DWT = DM1_vs_DWT[!is.na(DM1_vs_DWT$padj),] #remove NAs
sum(DM1_vs_DWT$padj < 0.01)


#SMC_vs_DWT
SMC_vs_DWT = results(nb, contrast=c("condition", "Smchd1", "DWT"), independentFiltering = TRUE, alpha=0.1, test="Wald")
hist(SMC_vs_DWT$pvalue)
SMC_vs_DWT = SMC_vs_DWT[!is.na(SMC_vs_DWT$padj),] #remove NAs
sum(SMC_vs_DWT$padj < 0.01)


#SMC_vs_DM1
SMC_vs_DM1 = results(nb, contrast=c("condition", "Smchd1", "DMUT1"), independentFiltering = TRUE, alpha=0.1, test="Wald")
hist(SMC_vs_DM1$pvalue)
SMC_vs_DM1 = SMC_vs_DM1[!is.na(SMC_vs_DM1$padj),] #remove NAs
sum(SMC_vs_DM1$padj < 0.01)

```


To compare expression across all conditions, use the negative binomial likelihood ratio test (nbinomLRT). This is analogous to ANOVA, and allows the comparison of more than two groups. For the pairwise comparisons, a Wald test is used, though nbinomLRT would also be acceptable. It is easier here to use Wald, as it means you do not need to subset `dds`. Check for genes containing `NA` in `padj`. For all tests, set the FDR cutoff for significance at 0.01, since there are many genes being tested. Across all conditions, there are **858** significant DEGs. **60** for DMUT1 vs DWT, **765** for Smchd1 vs DWT, and **591** for Smchd1 vs DMUT1. Also check the histogram of p-values for all tests to ensure we do not observe batch effects.

#### Writing DEG tables [NOT RUN]
```{r, eval=F}
#DM1_vs_DWT
tmp = as.data.frame(DM1_vs_DWT)
tmp = tmp[order(row.names(tmp), decreasing = F),]
ann = as.data.frame(ensembl.genes[ensembl.genes$gene_id %in% row.names(tmp),1:5])
tmp2 = cbind(ann, tmp)
write.csv(tmp2, "DM1_vs_DWT.csv")


#SMC_vs_DWT
tmp = as.data.frame(SMC_vs_DWT)
tmp = tmp[order(row.names(tmp), decreasing = F),]
ann = as.data.frame(ensembl.genes[ensembl.genes$gene_id %in% row.names(tmp),1:5])
tmp2 = cbind(ann, tmp)
write.csv(tmp2, "SMC_vs_DWT.csv")


#SMC_vs_DM1
tmp = as.data.frame(SMC_vs_DM1)
tmp = tmp[order(row.names(tmp), decreasing = F),]
ann = as.data.frame(ensembl.genes[ensembl.genes$gene_id %in% row.names(tmp),1:5])
tmp2 = cbind(ann, tmp)
write.csv(tmp2, "SMC_vs_DM1.csv")
```


#### Examine SMCHD1 expression
```{r}
DM1_vs_DWT[row.names(DM1_vs_DWT) == "ENSDARG00000104374",] 
SMC_vs_DWT[row.names(SMC_vs_DWT) == "ENSDARG00000104374",] 

```
The log2foldchanges are negative, which indicates reduced expression in the mutant relative to wildtype. Confirms TPM results.

### MA and volcano plots
```{r}
library(scales)

#DM1_vs_DWT
plot(DM1_vs_DWT$log2FoldChange, -log10(DM1_vs_DWT$padj), xlim = c(-15, 15), col = alpha("dodgerblue",0.5), main = "Volcano, DMUT1 vs DWT")
abline(h = 2, v = c(-2,2)) #p = 0.01 and lfc = +/- 2

plotMA(DM1_vs_DWT, ylim=c(-15,15), main = "MA Plot, DMUT1 vs DWT")

#SMC_vs_DWT
plot(SMC_vs_DWT$log2FoldChange, -log10(SMC_vs_DWT$padj), xlim = c(-15, 15), col = alpha("seagreen",0.5), main = "Volcano, Smchd1 vs DWT")
abline(h = 2, v = c(-2,2))

plotMA(SMC_vs_DWT, ylim=c(-15,15), main = "MA Plot, Smchd1 vs DWT")

#SMC_vs_DM1
plot(SMC_vs_DM1$log2FoldChange, -log10(SMC_vs_DM1$padj), xlim = c(-15, 15), col = alpha("firebrick",0.5), main = "Volcano, Smchd1 vs DMUT1")
abline(h = 2, v = c(-2,2))

plotMA(SMC_vs_DM1, ylim=c(-15,15), main = "MA Plot, Smchd1 vs DMUT1")

```

Produce MA and volcano plots for the pairwise comparisons. MA plots show the difference in gene expression (log fold change) between two conditions, relative to the mean expression across those conditions. Each point represents a particular gene. A gene with a similar expression level in both conditions will be near y = 0. Being further from y = 0 indicates up/down regulation. To compare along the x-axis: For a typically lowly expressed gene (low mean count), there is lower statistical power for an observed expression difference than a highly expressed gene (high A). MA plots tend to have even dispersion relative to the y-axis, which then decreases as x increases. Grey points indicate non-significant data points.

Volcano plots compare adjusted p-value and log fold change. Here I use -log10(adjusted p-value) and log2(fold change). Again, each point represents a gene. The higher on the y-axis, the smaller the adjusted p-value. The more extreme the value on the x-axis, the greater the difference in expression levels across conditions. A greater dispersion means that the two groups have greater differences in gene expression.

As expected, DMUT1 vs DWT shows little expression difference. Smchd1 vs DWT shows the most expression difference, with slightly less between Smchd1 and DMUT1. It all makes sense given the PCA's placement of the samples.

These plots also allow us to see if any changes are particularly significant or large, so we can investigate those genes individually.

#### Identifying specific genes from volcano plots [WIP]
```{r}
library(ggrepel)

#DM1_vs_DWT
DM1_vs_DWT_d = as.data.frame(DM1_vs_DWT)
DM1_vs_DWT_d$name = row.names(DM1_vs_DWT_d)

ggplot(DM1_vs_DWT_d, aes(x = log2FoldChange, y = -log10(padj), label=name)) + geom_point(alpha = 0.5, color = "dodgerblue") + labs(title = "Volcano, DMUT1 vs DWT") + geom_text_repel(data = subset(DM1_vs_DWT_d, -log10(padj) > 10), size = 3)

#SMC_vs_DWT
SMC_vs_DWT_d = as.data.frame(SMC_vs_DWT)
SMC_vs_DWT_d$name = row.names(SMC_vs_DWT_d)

ggplot(SMC_vs_DWT_d, aes(x = log2FoldChange, y = -log10(padj), label=name)) + geom_point(alpha = 0.5, color = "seagreen") + labs(title = "Volcano, Smchd1 vs DWT") + geom_text_repel(data = subset(SMC_vs_DWT_d, -log10(padj) > 30), size = 3)

#SMC_vs_DM1
SMC_vs_DM1_d = as.data.frame(SMC_vs_DM1)
SMC_vs_DM1_d$name = row.names(SMC_vs_DM1_d)

ggplot(SMC_vs_DM1_d, aes(x = log2FoldChange, y = -log10(padj), label=name)) + geom_point(alpha = 0.5, color = "firebrick") + labs(title = "Volcano, Smchd1 vs DMUT1") + geom_text_repel(data = subset(SMC_vs_DM1_d, -log10(padj) > 40), size = 3)
```

The conditions for gene labelling can be adjusted by applying different logic in `subset()`. Warnings of the form: `Removed k rows containing missing values (geom_point)` are just indicators that k of the data points are outside either `xlim()` or `ylim()`.


### Z-scoring fold changes
```{r}
library(pheatmap)
sig_results = all_cond[all_cond$padj < 0.01,] #the significantly differentially expressed genes from earlier

#transform lfcs then z-score
rlg = rlog(nb)
rlg_sig = assay(rlg)[rownames(sig_results),]
rlg_z = t(apply(rlg_sig, 1, function(x){ (x - mean(x)) / sd(x)})) #normalize by z-scoring

thr = 2.5
sum(rlg_z > thr)
sum(rlg_z < -thr)
#little data lost from thresholding, but always check! 
#These can also be genes to investigate separately, due to their large scores

rlg_z[rlg_z > thr] = thr
rlg_z[rlg_z < -thr] = -thr
```


### K-means clustering
``` {r}
#determine number of clusters
library(cluster)

#use wss to choose number of clusters
set.seed(123)
k.max <- 15
#1 cluster will almost never be the answer, so we'll leave it out for better visual discrimination
wss <- sapply(2:k.max, 
              function(k){kmeans(rlg_z, k, nstart=10,iter.max = 15 )$tot.withinss})

plot(2:k.max, wss,
     type="b", pch = 19, frame = FALSE, 
     xlab="Number of clusters K",
     ylab="Total within-clusters sum of squares", main = "WSS")
#from wss, I think 5 would be a good value for nclust, based on the elbow method.

#silhouette width to select clusters
SIL = sapply(2:k.max, function(i) {
  results.coef.kmeans =  kmeans(rlg_z, i, nstart=50, iter.max=50)
    mean(silhouette(results.coef.kmeans$cluster, dist(rlg_z))[,3]) })
plot(c(0,SIL), type="b", main = "Silhouette Width")
#silhouette with says use 2 clusters, which is just unreasonable for the data. Small drop from 5 to 6

#k-means with 5 clusters
#clustering
set.seed(123)
nclust = 5
results.coef.kmeans =  kmeans(rlg_z, nclust, nstart=50, iter.max=50)
results.coef = rlg_z[order(results.coef.kmeans$cluster),]
indicator = results.coef.kmeans$cluster[order(results.coef.kmeans$cluster)]

#heatmapping
color = c(colorRampPalette(c("dodgerblue2", "white"))(14), colorRampPalette(c("white", "firebrick2"))(14))
breaksList = seq(-thr, thr, length.out = 29)

heat.map <- pheatmap(results.coef, cluster_col=F, breaks=breaksList, cluster_rows=F, show_rownames=FALSE,color = color,fontsize_row = 3, legend=TRUE,border_color = NA,main = "k-means clustering, k=5", labels_col = c("DMUT1_1","DMUT1_2","DMUT1_3","Smchd1_1","Smchd1_2","Smchd1_3","DWT1_1","DWT1_2","DWT1_3"), angle_col = 45)

#cluster sizes
table(results.coef.kmeans$cluster)

```

After performing a z-score normalization on the expression of significant DEGs across all conditions, calculate the WSS and silhouette width for 2 to 15 clusters, to determine the correct number of clusters for the analysis. Combine results of both statistics, k = 5 is a reasonable choice. Perform the clustering.
DMUT1 and DWT1 are similar in this expression heatmap.

Cluster 1 is up in Smchd1 and down in the others.
Cluster 2 is up in Smchd1, down in DWT1, and neutral to slightly up in DMUT1.
Cluster 3 is down in Smchd1 and up in the others.
Cluster 4 is variable in Smchd1, down in DMUT1, and up in DWT1.
Cluster 5 is down in Smchd1, up in DMUT1, and variable to slightly up in DWT1.



### GO:BP enrichment of clusters
```{r}
library(clusterProfiler)
library(org.Dr.eg.db)
library(stringr)
library(ggplot2)

bp = list()
for (i in 1:nclust) {
  bp[i] = enrichGO(gene          = names(results.coef.kmeans$cluster[results.coef.kmeans$cluster==i]),
                universe      = rownames(nb),
                OrgDb         = org.Dr.eg.db,
                keyType       = 'ENSEMBL',
                ont           = "BP",
                pAdjustMethod = "BH",
                pvalueCutoff  = 1,
                qvalueCutoff  = 0.1,
                readable      = TRUE)
#gene identifiers are ensemble IDs
#orgdb = organism annotation
#ont           = ontology. GO has MF (molecular function), BP (biological process), CC (cellular component).
#universe = all of the genes, after filtering out rRNA/mtRNA and low expression crap
#padj = FDR method
#no pvalue cutoff

}
#ignore the warning messages

#first check if any of the clusters produce no enrichments
# head(bp[[1]])
# head(bp[[2]])
# head(bp[[3]]) # only 2
# head(bp[[4]])
# head(bp[[5]]) # no result


#the top 10 terms in the cluster. gene ratio is the number you observe vs expected, like effect size

dotplot(bp[[1]], title = "GO:BP Enrichment of Cluster 1", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40))

dotplot(bp[[2]], title = "GO:BP Enrichment of Cluster 2", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40))

dotplot(bp[[3]], title = "GO:BP Enrichment of Cluster 3", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40))

dotplot(bp[[4]], title = "GO:BP Enrichment of Cluster 4", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40))

#dotplot(bp[[5]], title = "GO:BP Enrichment of Cluster 5", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40))


```


### GO:MF enrichment of clusters
``` {r}
mf = list()
for (i in 1:nclust) {
  mf[i] = enrichGO(gene          = names(results.coef.kmeans$cluster[results.coef.kmeans$cluster==i]),
                universe      = rownames(nb),
                OrgDb         = org.Dr.eg.db,
                keyType       = 'ENSEMBL',
                ont           = "MF",
                pAdjustMethod = "BH",
                pvalueCutoff  = 1,
                qvalueCutoff  = 0.1,
                readable      = TRUE)
}

# head(mf[[1]])#no enrichment
# head(mf[[2]])#no enrichment
# head(mf[[3]])#no enrichment
head(mf[[4]]) 
# head(mf[[5]])#no enrichment


# dotplot(mf[[1]], title = "GO:MF Enrichment of Cluster 1", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40))
# 
# dotplot(mf[[2]], title = "GO:MF Enrichment of Cluster 2", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40))
# 
# dotplot(mf[[3]], title = "GO:MF Enrichment of Cluster 3", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40))

dotplot(mf[[4]], title = "GO:MF Enrichment of Cluster 4", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40))

# dotplot(mf[[5]], title = "GO:MF Enrichment of Cluster 5", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40))

```


### KEGG enrichment of clusters
``` {r}
kegg = list()
for (i in 1:nclust) {
  kegg[i] = enrichKEGG(gene          = as.character(ensembl.genes[ensembl.genes$gene_id %in% names(results.coef.kmeans$cluster[results.coef.kmeans$cluster==i])]$entrezgene_id),
              universe      = as.character(ensembl.genes[ensembl.genes$gene_id %in% rownames(dds)]$entrezgene_id),
              organism         = "dre",
              qvalueCutoff  = 0.1)

}


# head(kegg[[1]])#no enrichment
# head(kegg[[2]])#no enrichment
head(kegg[[3]])
head(kegg[[4]]) 
# head(kegg[[5]])#no enrichment


#the top 10 terms in the cluster. gene ratio is the number you observe vs expected, like effect size
# dotplot(kegg[[1]], title = "KEGG Enrichment of Cluster 1", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40))
# 
# dotplot(kegg[[2]], title = "KEGG Enrichment of Cluster 2", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40))

dotplot(kegg[[3]], title = "KEGG Enrichment of Cluster 3", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40))

dotplot(kegg[[4]], title = "KEGG Enrichment of Cluster 4", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40))

# dotplot(kegg[[5]], title = "KEGG Enrichment of Cluster 5", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40))


```


### Analyzing only Smchd1 and DWT

#### Clustering Smchd1-DWT
```{r}
#i can start with the SMC_vs_DWT data?

sig_results = SMC_vs_DWT[SMC_vs_DWT$padj < 0.01,] 

#transform lfcs then z-score
rlg = rlog(nb)
rlg_sig = assay(rlg)[rownames(sig_results),-c(1:3)]
rlg_z = t(apply(rlg_sig, 1, function(x){ (x - mean(x)) / sd(x)})) #normalize by z-scoring

thr = 2
sum(rlg_z > thr)
sum(rlg_z < -thr)
#little data lost from thresholding, but always check! 
#These can also be genes to investigate separately, due to their large scores

rlg_z[rlg_z > thr] = thr
rlg_z[rlg_z < -thr] = -thr

#in this case it is worth performing hierarchical clustering. 
dd = dist(rlg_z)
clusters.hclust = hclust(dd) #you can choose the agglomeration method here, which would change the end results. 

color = c(colorRampPalette(c("dodgerblue2", "white"))(14), colorRampPalette(c("white", "firebrick2"))(14))
breaksList = seq(-thr, thr, length.out = 29)
heat.map <- pheatmap(rlg_z, cluster_col=FALSE, breaks=breaksList, cluster_rows=clusters.hclust, show_rownames=FALSE,color = color,fontsize_row = 3, legend=TRUE,border_color = NA,main = "Hierarchichal clustering", labels_col = c("Smchd1_1","Smchd1_2","Smchd1_3","DWT1_1","DWT1_2","DWT1_3"), angle_col = 45)


#use wss to choose number of clusters
set.seed(123)
k.max <- 15
#1 cluster will almost never be the answer, so we'll leave it out for better visual discrimination
wss <- sapply(2:k.max, 
              function(k){kmeans(rlg_z, k, nstart=10,iter.max = 15 )$tot.withinss})

plot(2:k.max, wss,
     type="b", pch = 19, frame = FALSE, 
     xlab="Number of clusters K",
     ylab="Total within-clusters sum of squares", main = "WSS")
#from wss, I think 5 would be a good value for nclust, based on the elbow method.

#silhouette width to select clusters
SIL = sapply(2:k.max, function(i) {
  results.coef.kmeans =  kmeans(rlg_z, i, nstart=50, iter.max=50)
    mean(silhouette(results.coef.kmeans$cluster, dist(rlg_z))[,3]) })
plot(c(0,SIL), type="b", main = "Silhouette Width")
#silhouette with says use 2 clusters, which is just unreasonable for the data. Small drop from 5 to 6

#k-means with 6 clusters
#clustering
set.seed(123)
nclust = 2
results.coef.kmeans =  kmeans(rlg_z, nclust, nstart=50, iter.max=50)
results.coef = rlg_z[order(results.coef.kmeans$cluster),]
indicator = results.coef.kmeans$cluster[order(results.coef.kmeans$cluster)]

#heatmapping
color = c(colorRampPalette(c("dodgerblue2", "white"))(14), colorRampPalette(c("white", "firebrick2"))(14))
breaksList = seq(-thr, thr, length.out = 29)

heat.map <- pheatmap(results.coef, cluster_col=F, breaks=breaksList, cluster_rows=F, show_rownames=FALSE,color = color,fontsize_row = 3, legend=TRUE,border_color = NA,main = paste("k-means clustering, k =",nclust), labels_col = c("Smchd1_1","Smchd1_2","Smchd1_3","DWT1_1","DWT1_2","DWT1_3"), angle_col = 45)

#cluster sizes
table(results.coef.kmeans$cluster)



```

In clustering the Smchd1 and DWT samples, the approach is slightly different from before. Since there are only two kinds of sample, there are 4 outcomes for a given gene: up/up, down/down, up/down, down/up. As we are clustering the genes that are significantly differentially expressed, very few genes will fall into the first two categories. Therefore, we can expect two clusters. Thus we have a strong argument for assigning k = 2. We can also perform hierarchical clustering before k-means to test that idea. Hierarchical clustering makes no assumption about the number of clusters in the data. Given that we roughly observe 2 clusters, we have greater confidence in k = 2. Aside from k-means, cutting hclust at k = 2 will also generate gene sets for enrichment. We still check silhouette and wss, but they are not very informative in this case. 


#### Enriching Smchd1-DWT clusters

```{r}
bp = list()
for (i in 1:nclust) {
  bp[i] = enrichGO(gene          = names(results.coef.kmeans$cluster[results.coef.kmeans$cluster==i]),
                universe      = rownames(nb),
                OrgDb         = org.Dr.eg.db,
                keyType       = 'ENSEMBL',
                ont           = "BP",
                pAdjustMethod = "BH",
                pvalueCutoff  = 1,
                qvalueCutoff  = 0.1,
                readable      = TRUE)
#gene identifiers are ensemble IDs
#orgdb = organism annotation
#ont           = ontology. GO has MF (molecular function), BP (biological process), CC (cellular component).
#universe = all of the genes, after filtering out rRNA/mtRNA and low expression crap
#padj = FDR method
#no pvalue cutoff

}
#ignore the warning messages

#first check if any of the clusters produce no enrichments
# head(bp[[1]]) #this is surprising
# head(bp[[2]])



#the top 10 terms in the cluster. gene ratio is the number you observe vs expected, like effect size

#dotplot(bp[[1]], title = "GO:BP Enrichment of Smchd1-DWT Cluster 1", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40))

dotplot(bp[[2]], title = "GO:BP Enrichment of Smchd1-DWT Cluster 2", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40))
```

``` {r}
mf = list()
for (i in 1:nclust) {
  mf[i] = enrichGO(gene          = names(results.coef.kmeans$cluster[results.coef.kmeans$cluster==i]),
                universe      = rownames(nb),
                OrgDb         = org.Dr.eg.db,
                keyType       = 'ENSEMBL',
                ont           = "MF",
                pAdjustMethod = "BH",
                pvalueCutoff  = 1,
                qvalueCutoff  = 0.1,
                readable      = TRUE)
}

# head(mf[[1]])#no enrichment
# head(mf[[2]])#no enrichment
```

``` {r}
kegg = list()
for (i in 1:nclust) {
  kegg[i] = enrichKEGG(gene          = as.character(ensembl.genes[ensembl.genes$gene_id %in% names(results.coef.kmeans$cluster[results.coef.kmeans$cluster==i])]$entrezgene_id),
              universe      = as.character(ensembl.genes[ensembl.genes$gene_id %in% rownames(nb)]$entrezgene_id),
              organism         = "dre",
              qvalueCutoff  = 0.1)

}


# head(kegg[[1]])
head(kegg[[2]])#no enrichment


#the top 10 terms in the cluster. gene ratio is the number you observe vs expected, like effect size
dotplot(kegg[[1]], title = "KEGG Enrichment of Smchd1-DWT Cluster 1", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40))



```

GO:BP produced enrichment for cluster 2 only. GO:MF produced enrichment for neither cluster. KEGG produced enrichment for 1 term in cluster 1.

### Gene set enrichment analysis
``` {r}
library(fgsea)
library(msigdbr)
library(dplyr)
library(gridExtra)

#get gene sets
#msigdbr_species()

#You must select a collection (the category argument). descriptions are on http://www.gsea-msigdb.org/gsea/msigdb/index.jsp
collection = "H"
d_df = msigdbr(species = "Danio rerio", category = collection)
#length(unique(m_df$gs_name))# number of genesets
fgsea_sets = d_df %>% split(x = .$ensembl_gene, f = .$gs_name) #msigdb now supports ensembl! used to be entrezgene
```
For the moment, we are only looking at MSigDB's hallmark gene sets. From MSigDB: "Hallmark gene sets summarize and represent specific well-defined biological states or processes and display coherent expression. These gene sets were generated by a computational methodology based on identifying gene set overlaps and retaining genes that display coordinate expression. The hallmarks reduce noise and redundancy and provide a better delineated biological space for GSEA. We refer to the original overlapping gene sets, from which a hallmark is derived, as its 'founder' sets. Hallmark gene set pages provide links to the corresponding founder sets for deeper follow up."

All gene set descriptions here: http://www.gsea-msigdb.org/gsea/msigdb/index.jsp

**The most relevant collections for this experiment are C3, or external development related gene sets.**

#### DMUT1 vs DWT
```{r}
changes = DM1_vs_DWT #recall that this is before we got significant_results, but after we cleaned and ran negbinom/wald. premise of gsea is that the individual expression changes needn't be significant, so this is what we want to search within.
# sum(ensembl.genes$gene_id %in% row.names(changes)) #the number of genes we matched in the annotation
# changes[!(row.names(changes) %in% ensembl.genes$gene_id),] #the genes in the data we failed to match. They simply do not exist in the annotation. Strange.


ensembl_sub = ensembl.genes[ensembl.genes$gene_id %in% row.names(changes), ] #subset annotation according to overlap
changes_sub = changes[row.names(changes) %in% ensembl.genes$gene_id, ] #subset change data according to overlap

changes_sub = changes_sub[order(row.names(changes_sub)),] #ensure genes are in same order as annotation
sum(ensembl_sub$gene_id == row.names(changes_sub)) #are all gene ids identical?

ensembl_sub$log2FoldChange = changes_sub$log2FoldChange #get corresponding foldchanges

#create vector of fold changes to be ranked by lfc
ensembl_sub_lfc = ensembl_sub$log2FoldChange
names(ensembl_sub_lfc) = ensembl_sub$gene_id

#order by lfc
ensembl_sub_lfc = ensembl_sub_lfc[order(ensembl_sub_lfc, decreasing = T)]
#filter for protein coding genes
ensembl_sub_lfc = ensembl_sub_lfc[names(ensembl_sub_lfc) %in% ensembl_sub$gene_id[ensembl_sub$gene_biotype=="protein_coding"]]
#run gsea
fgseaRes <- fgseaMultilevel(pathways = fgsea_sets, 
                  stats = ensembl_sub_lfc,
                  minSize = 1,
                  maxSize = 500,
                  eps = 0)

#plot
fgseaResTidy = fgseaRes %>% as_tibble() %>% arrange(desc(NES))
fgseaResTidy %>% dplyr::select(-leadingEdge, -ES) %>% arrange(padj) 
ggplot(fgseaResTidy %>% filter(padj < 0.05) %>% head(n= 20), aes(reorder(pathway, NES), NES)) + coord_flip() + geom_col(aes(fill = NES < 2.5)) + labs(x="Term", y="Normalized Enrichment Score", title=paste("GSEA of DMUT1 vs DWT, on Ontology Gene Set",collection)) + theme_minimal() + scale_y_discrete(labels=function(x) str_wrap(x, width=40))

#we can also look at a specific term's enrichment
plotEnrichment(fgsea_sets[["HALLMARK_ALLOGRAFT_REJECTION"]], ensembl_sub_lfc) + labs(title="HALLMARK_ALLOGRAFT_REJECTION")
```

```{r}
#need a separate chunk or it won't knit properly
#another way to visualize gsea
topPathwaysUp <- fgseaRes[ES > 0][head(order(padj), n=10), pathway]
topPathwaysDown <- fgseaRes[ES < 0][head(order(padj), n=10), pathway]
topPathways <- c(topPathwaysUp, rev(topPathwaysDown))
plotGseaTable(fgsea_sets[topPathways], ensembl_sub_lfc, fgseaRes, gseaParam = 0.5, render = T)
```


#### Smchd1 vs DWT
```{r}
changes = SMC_vs_DWT #recall that this is before we got significant_results, but after we cleaned and ran negbinom/wald. premise of gsea is that the individual expression changes needn't be significant, so this is what we want to search within.
# sum(ensembl.genes$gene_id %in% row.names(changes)) #the number of genes we matched in the annotation
# changes[!(row.names(changes) %in% ensembl.genes$gene_id),] #the genes in the data we failed to match. They simply do not exist in the annotation. Strange.


ensembl_sub = ensembl.genes[ensembl.genes$gene_id %in% row.names(changes), ] #subset annotation according to overlap
changes_sub = changes[row.names(changes) %in% ensembl.genes$gene_id, ] #subset change data according to overlap

changes_sub = changes_sub[order(row.names(changes_sub)),] #ensure genes are in same order as annotation
sum(ensembl_sub$gene_id == row.names(changes_sub)) #are all gene ids identical?

ensembl_sub$log2FoldChange = changes_sub$log2FoldChange #get corresponding foldchanges

#create vector of fold changes to be ranked by lfc
ensembl_sub_lfc = ensembl_sub$log2FoldChange
names(ensembl_sub_lfc) = ensembl_sub$gene_id

#order by lfc
ensembl_sub_lfc = ensembl_sub_lfc[order(ensembl_sub_lfc, decreasing = T)]
#filter for protein coding genes
ensembl_sub_lfc = ensembl_sub_lfc[names(ensembl_sub_lfc) %in% ensembl_sub$gene_id[ensembl_sub$gene_biotype=="protein_coding"]]
#run gsea
fgseaRes <- fgseaMultilevel(pathways = fgsea_sets, 
                  stats = ensembl_sub_lfc,
                  minSize = 1,
                  maxSize = 500,
                  eps = 0)

#plot
fgseaResTidy = fgseaRes %>% as_tibble() %>% arrange(desc(NES))
fgseaResTidy %>% dplyr::select(-leadingEdge, -ES) %>% arrange(padj) 
ggplot(fgseaResTidy %>% filter(padj < 0.05) %>% head(n= 20), aes(reorder(pathway, NES), NES)) + coord_flip() + geom_col(aes(fill = NES < 2.5)) + labs(x="Term", y="Normalized Enrichment Score", title=paste("GSEA of Smchd1 vs DWT, on Ontology Gene Set",collection)) + theme_minimal() + scale_y_discrete(labels=function(x) str_wrap(x, width=40))

```

```{r}
#need a separate chunk or it won't knit properly
#another way to visualize gsea
topPathwaysUp <- fgseaRes[ES > 0][head(order(padj), n=10), pathway]
topPathwaysDown <- fgseaRes[ES < 0][head(order(padj), n=10), pathway]
topPathways <- c(topPathwaysUp, rev(topPathwaysDown))
plotGseaTable(fgsea_sets[topPathways], ensembl_sub_lfc, fgseaRes, gseaParam = 0.5, render = T)
```


#### Smchd1 vs DMUT1
```{r}
changes = SMC_vs_DM1 #recall that this is before we got significant_results, but after we cleaned and ran negbinom/wald. premise of gsea is that the individual expression changes needn't be significant, so this is what we want to search within.
# sum(ensembl.genes$gene_id %in% row.names(changes)) #the number of genes we matched in the annotation
# changes[!(row.names(changes) %in% ensembl.genes$gene_id),] #the genes in the data we failed to match. They simply do not exist in the annotation. Strange.


ensembl_sub = ensembl.genes[ensembl.genes$gene_id %in% row.names(changes), ] #subset annotation according to overlap
changes_sub = changes[row.names(changes) %in% ensembl.genes$gene_id, ] #subset change data according to overlap

changes_sub = changes_sub[order(row.names(changes_sub)),] #ensure genes are in same order as annotation
sum(ensembl_sub$gene_id == row.names(changes_sub)) #are all gene ids identical?

ensembl_sub$log2FoldChange = changes_sub$log2FoldChange #get corresponding foldchanges

#create vector of fold changes to be ranked by lfc
ensembl_sub_lfc = ensembl_sub$log2FoldChange
names(ensembl_sub_lfc) = ensembl_sub$gene_id

#order by lfc
ensembl_sub_lfc = ensembl_sub_lfc[order(ensembl_sub_lfc, decreasing = T)]
#filter for protein coding genes
ensembl_sub_lfc = ensembl_sub_lfc[names(ensembl_sub_lfc) %in% ensembl_sub$gene_id[ensembl_sub$gene_biotype=="protein_coding"]]
#run gsea
fgseaRes <- fgseaMultilevel(pathways = fgsea_sets, 
                  stats = ensembl_sub_lfc,
                  minSize = 1,
                  maxSize = 500,
                  eps = 0)

#plot
fgseaResTidy = fgseaRes %>% as_tibble() %>% arrange(desc(NES))
fgseaResTidy %>% dplyr::select(-leadingEdge, -ES) %>% arrange(padj) 
ggplot(fgseaResTidy %>% filter(padj < 0.05) %>% head(n= 20), aes(reorder(pathway, NES), NES)) + coord_flip() + geom_col(aes(fill = NES < 2.5)) + labs(x="Term", y="Normalized Enrichment Score", title=paste("GSEA of Smchd1 vs DMUT1, on Ontology Gene Set",collection)) + theme_minimal() + scale_y_discrete(labels=function(x) str_wrap(x, width=40))

```

```{r}
#need a separate chunk or it won't knit properly
#another way to visualize gsea
topPathwaysUp <- fgseaRes[ES > 0][head(order(padj), n=10), pathway]
topPathwaysDown <- fgseaRes[ES < 0][head(order(padj), n=10), pathway]
topPathways <- c(topPathwaysUp, rev(topPathwaysDown))
plotGseaTable(fgsea_sets[topPathways], ensembl_sub_lfc, fgseaRes, gseaParam = 0.5, render = T)
```





### END














