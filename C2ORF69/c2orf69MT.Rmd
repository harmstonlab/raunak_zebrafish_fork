---
title: "C2ORF69"
author: "Raunak Vijayakar"
date: "dd/mm/yyyy"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



### Raw counts and annotation
Starting with the txt output from featureCounts, you need to manually delete the first row (which contains command input information), and then the name of the first column (gene id). Then when you read the file as below, it will be correctly formatted.
```{r}
library(biomaRt)
library(DESeq2)
library(GenomicFeatures)

c2 = read.delim("c2orf69_counts copy.txt", sep = "")
c2 = c2[,-c(1:5,13)] #remove unnecessary columns and WT1_2 because it looks like an outlier sample


#exclude any rows where no counts were found for any condition
c2 = c2[rowSums(c2) > 0, ]

#take a look at the reads for each condition
barplot(colSums(c2), ylab="Number of aligned reads", las=2, cex.names=0.8)
#numbers are similar across all samples


#get matching annotations
dr.gtf.db <- makeTxDbFromGFF("Danio_rerio.GRCz11.104.chr.gtf", format="gtf")
ensembl.genes = genes(dr.gtf.db)
fish = useEnsembl(biomart="ENSEMBL_MART_ENSEMBL", host = "useast.ensembl.org", dataset="drerio_gene_ensembl", version = "104") #change host as needed
head(listAttributes(fish))#annotations we can request

bm.annotations = getBM(attributes=c("ensembl_gene_id", "entrezgene_id", "gene_biotype", "description", "zfin_id_symbol"), mart=fish, filters="ensembl_gene_id", values=ensembl.genes$gene_id, uniqueRows=TRUE) #error here sometimes, 104 db connection issue??
#also hgnc is so sparse that it could be dropped without consequence

ensembl.genes$zfin_id_symbol = bm.annotations$zfin_id_symbol[ match(ensembl.genes$gene_id, bm.annotations$ensembl_gene_id) ]
ensembl.genes$gene_biotype = bm.annotations$gene_biotype[ match(ensembl.genes$gene_id, bm.annotations$ensembl_gene_id) ]
ensembl.genes$status = bm.annotations$status[ match(ensembl.genes$gene_id, bm.annotations$ensembl_gene_id) ]
ensembl.genes$description = bm.annotations$description[ match(ensembl.genes$gene_id, bm.annotations$ensembl_gene_id) ]
ensembl.genes$entrezgene_id = bm.annotations$entrezgene_id[ match(ensembl.genes$gene_id, bm.annotations$ensembl_gene_id) ]



```




### DDS and Filtering
```{r}
#see how many reads are in rRNA/MT rRNA
rrna = names(ensembl.genes[ensembl.genes$gene_biotype %in% c("Mt_rRNA", "rRNA" )]) #all possible rrnas, not just the ones found in the actual data
total.rrna = colSums(c2[row.names(c2) %in% rrna,])
barplot(100 * (total.rrna / colSums(c2)), ylab="%rRNA/mtRNA", las=2, cex.names=0.8)
length(rrna)
#how many reads are in mitochondrial chromosome?
chrM = names(ensembl.genes[ensembl.genes@seqnames %in% "MT", ])
total.mchrom = colSums(c2[row.names(c2) %in% chrM,])
barplot(100 * (total.mchrom / colSums(c2)), ylab="%MT", las=2, cex.names=0.8)


#remove rRNA and mtRNA
c2 = c2[!(row.names(c2) %in% rrna),]
# #remove mitochondrial chromosome reads
# c2 = c2[!(row.names(c2) %in% chrM),]


met = read.csv("c2orf69_metadata.csv") #sample ids and conditions. no batch indicator, so we won't be controlling for that.

dds = DESeqDataSetFromMatrix(c2, met, ~ condition)

dds

dds <- estimateSizeFactors(dds)
dds <- estimateDispersions(dds) #this helps us deal w/fact that we don't have 30 samples/condition

#normalize for read depth
head(counts(dds))
head(counts(dds, normalized=TRUE)) #can do this because we called sizefactors b/f, these number can be compared directly, across condition, not across gene though

#only choosing genes that have a normalized mean expression across conditions >= 10. This removes lowly expressed genes that are hard to differentiate from noise. could also be done after examining p-value histogram of a significance test, comparing pre- and post-filtering.
filter = apply(counts(dds, normalized=TRUE), 1, function(x){ mean(x) >= 10 })
dds = dds[filter, ]


#apply regularized log transform. 
rld <- rlog(dds)



```



### PCA
``` {r}
#do PCA
plotPCA(rld, intgroup = c( "condition"))
plotPCA(rld, intgroup = c( "sample_id"))


```

Substantial variation within groups (except WT, since we removed the outlier sample WT1_2).

### Investigate C2orf69 knockout [NOT RUN]
Look at expression levels for ENSDARG00000062425.
```{r, eval=F}

tmp = assay(rld)
tmp[row.names(tmp) == "ENSDARG00000062425"]


#calculate TPM
dr.exons = exonsBy(dr.gtf.db, "gene")
dr.exons = reduce(dr.exons) #we're not using ignore.strand here. why?
dr.lengths = sapply(dr.exons, function(x){sum(width(x))})

gene_lengths = dr.lengths / 1000
#normalize for gene length
rpk = c2 / gene_lengths[row.names(c2)]
#normalize for read depth
ncscalingfactor = colSums(rpk) / 1e6
tpm = sweep(rpk, 2, ncscalingfactor, "/")

colSums(tpm)
#tpm tells you what proportion of reads (of the total reads per sample) mapped to a gene, so you can compare across samples by gene
#this is the most fitting measure for RNAseq
head(tpm)
#but this is ultimately an academic exercise, as we won't be inputting the tpms calculated here for deseq, we use rlog.
tpm[row.names(tpm) == "ENSDARG00000062425",]

```
The TPM calculations suggest that the mutant gene had roughly the same expression in mutants as wild type. This indicates that the mutated mRNA is not degraded by non-specific degradation pathways. Not that the resultant protein is not mutatated as intended.


### Differential expression analysis
```{r}
#all_cond
#since condition is the only contrast, reduced model won't be controlling for sex, batch, etc.
nb = nbinomLRT(dds, full = design(dds), reduced = ~1)
all_cond = results(nb)
hist(all_cond$pvalue)
#though the listed foldchange is calculated for some pair of conditions, the p-value from nbinomlrt is for all conditions.

sum(is.na(all_cond$padj)) #190 genes have NA p-values and padj

###explanation from DESeq2 vignette:###
# If a row contains a sample with an extreme count outlier then the p value and adjusted p value will be set to NA. These outlier counts are detected by Cookâ€™s distance.

#For now I will remove these genes and move on, but they might deserve another look
all_cond = all_cond[!is.na(all_cond$padj),]

#significance level of 0.01 for FDR. this is a cutoff for the expected false positive rate (proportion of DEGs that were false to total DEGs). since we have a lot of genes, this seems like a reasonable alpha.
sum(all_cond$padj < 0.01)

#M1_vs_WT
M1_vs_WT = results(nb, contrast=c("condition", "MUT1", "WT"), independentFiltering = TRUE, alpha=0.1, test="Wald")
hist(M1_vs_WT$pvalue) #Potential batch effect indicated here. Would not be surprised based on the PCA.
M1_vs_WT = M1_vs_WT[!is.na(M1_vs_WT$padj),] #remove NAs
sum(M1_vs_WT$padj < 0.01)


#M2_vs_WT
M2_vs_WT = results(nb, contrast=c("condition", "MUT2", "WT"), independentFiltering = TRUE, alpha=0.1, test="Wald")
hist(M2_vs_WT$pvalue) #textbook anticonservative p-values
M2_vs_WT = M2_vs_WT[!is.na(M2_vs_WT$padj),] #remove NAs
sum(M2_vs_WT$padj < 0.01)


#M1_vs_M2
M1_vs_M2 = results(nb, contrast=c("condition", "MUT1", "MUT2"), independentFiltering = TRUE, alpha=0.1, test="Wald")
hist(M1_vs_M2$pvalue) #also good
M1_vs_M2 = M1_vs_M2[!is.na(M1_vs_M2$padj),] #remove NAs
sum(M1_vs_M2$padj < 0.01)

```


To compare expression across all conditions, use the negative binomial likelihood ratio test (nbinomLRT). This is analogous to ANOVA, and allows the comparison of more than two groups. For the pairwise comparisons, a Wald test is used, though nbinomLRT would also be acceptable. It is easier here to use Wald, as it means you do not need to subset `dds`. Check for genes containing `NA` in `padj`. For all tests, set the FDR cutoff for significance at 0.01, since there are many genes being tested. Across all conditions, there are **770** significant DEGs. **28** for MUT1 vs WT, **479** for MUT2 vs WT, and **636** for MUT1 vs MUT2. There are relatively few significant DEGs in MUT1 vs WT, and the p-value histogram looks almost uniform or slightly skewed, potentially an indicator of batch effects (which we cannot control for in this case). But because we used B-H correction, we did find the small percentage of non-null hypotheses.

#### Writing DEG tables [NOT RUN]
```{r, eval=F}
#M1_vs_WT
tmp = as.data.frame(M1_vs_WT)
tmp = tmp[order(row.names(tmp), decreasing = F),]
ann = as.data.frame(ensembl.genes[ensembl.genes$gene_id %in% row.names(tmp),1:5])
tmp2 = cbind(ann, tmp)
write.csv(tmp2, "M1_vs_WT.csv")


#M2_vs_WT
tmp = as.data.frame(M2_vs_WT)
tmp = tmp[order(row.names(tmp), decreasing = F),]
ann = as.data.frame(ensembl.genes[ensembl.genes$gene_id %in% row.names(tmp),1:5])
tmp2 = cbind(ann, tmp)
write.csv(tmp2, "M2_vs_WT.csv")


#M1_vs_M2
tmp = as.data.frame(M1_vs_M2)
tmp = tmp[order(row.names(tmp), decreasing = F),]
ann = as.data.frame(ensembl.genes[ensembl.genes$gene_id %in% row.names(tmp),1:5])
tmp2 = cbind(ann, tmp)
write.csv(tmp2, "M1_vs_M2.csv")
```



#### Examine C2ORF69 expression
```{r}
M1_vs_WT[row.names(M1_vs_WT) == "ENSDARG00000062425",] 
M2_vs_WT[row.names(M2_vs_WT) == "ENSDARG00000062425",] 
M1_vs_M2[row.names(M1_vs_M2) == "ENSDARG00000062425",]
```
The log2foldchanges are positive between the mutants and wildtype, confirming TPM calculations. Almost no expression change comparing mutants to eachother, which is expected.

### MA and volcano plots
```{r}
library(scales)

#M1_vs_WT
plot(M1_vs_WT$log2FoldChange, -log10(M1_vs_WT$padj), xlim = c(-15, 15), col = alpha("dodgerblue",0.5), main = "Volcano, MUT1 vs WT")
abline(h = 2, v = c(-2,2)) #p = 0.01 and lfc = +/- 2

plotMA(M1_vs_WT, ylim=c(-15,15), main = "MA Plot, MUT1 vs WT")

#M2_vs_WT
plot(M2_vs_WT$log2FoldChange, -log10(M2_vs_WT$padj), xlim = c(-15, 15), col = alpha("seagreen",0.5), main = "Volcano, MUT2 vs WT")
abline(h = 2, v = c(-2,2))

plotMA(M2_vs_WT, ylim=c(-15,15), main = "MA Plot, MUT2 vs WT")

#M1_vs_M2
plot(M1_vs_M2$log2FoldChange, -log10(M1_vs_M2$padj), xlim = c(-15, 15), col = alpha("firebrick",0.5), main = "Volcano, MUT1 vs MUT2")
abline(h = 2, v = c(-2,2))

plotMA(M1_vs_M2, ylim=c(-15,15), main = "MA Plot, MUT1 vs MUT2")

```

Produce MA and volcano plots for the pairwise comparisons. MA plots show the difference in gene expression (log fold change) between two conditions, relative to the mean expression across those conditions. Each point represents a particular gene. A gene with a similar expression level in both conditions will be near y = 0. Being further from y = 0 indicates up/down regulation. To compare along the x-axis: For a typically lowly expressed gene (low mean count), there is lower statistical power for an observed expression difference than a highly expressed gene (high A). MA plots tend to have even dispersion relative to the y-axis, which then decreases as x increases. Grey points indicate non-significant data points.

Volcano plots compare adjusted p-value and log fold change. Here I use -log10(adjusted p-value) and log2(fold change). Again, each point represents a gene. The higher on the y-axis, the smaller the adjusted p-value. The more extreme the value on the x-axis, the greater the difference in expression levels across conditions. A greater dispersion means that the two groups have greater differences in gene expression.

As expected, MUT1 vs WT shows little expression difference. MUT2 vs WT shows more differential expression, with an upregulation bias. MUT1 vs MUT2 shows similar differential expression as MUT2 vs WT, with a downregulation bias. If we ran MUT2 vs MUT1 it should look very similar to MUT2 vs WT (MUT2 vs WT = MUT2/WT, MUT1 vs MUT2 = MUT1/MUT2). These all suggest that MUT1 and WT are similar to each other and different from MUT2, confirming the PCA.

These plots also allow us to see if any changes are particularly significant or large, so we can investigate those genes individually.

#### Identifying specific genes from volcano plots [WIP]
```{r}
library(ggrepel)

#M1_vs_WT
M1_vs_WT_d = as.data.frame(M1_vs_WT)
M1_vs_WT_d$name = row.names(M1_vs_WT_d)

ggplot(M1_vs_WT_d, aes(x = log2FoldChange, y = -log10(padj), label=name)) + geom_point(alpha = 0.5, color = "dodgerblue") + labs(title = "Volcano, MUT1 vs WT") + geom_text_repel(data = subset(M1_vs_WT_d, -log10(padj) > 2 & abs(log2FoldChange) > 2), size = 3)

#M2_vs_WT
M2_vs_WT_d = as.data.frame(M2_vs_WT)
M2_vs_WT_d$name = row.names(M2_vs_WT_d)

ggplot(M2_vs_WT_d, aes(x = log2FoldChange, y = -log10(padj), label=name)) + geom_point(alpha = 0.5, color = "seagreen") + labs(title = "Volcano, MUT2 vs WT") + geom_text_repel(data = subset(M2_vs_WT_d, -log10(padj) > 10), size = 3)

#M1_vs_M2
M1_vs_M2_d = as.data.frame(M1_vs_M2)
M1_vs_M2_d$name = row.names(M1_vs_M2_d)

ggplot(M1_vs_M2_d, aes(x = log2FoldChange, y = -log10(padj), label=name)) + geom_point(alpha = 0.5, color = "firebrick") + labs(title = "Volcano, MUT1 vs MUT2") + geom_text_repel(data = subset(M1_vs_M2_d, -log10(padj) > 15), size = 3)
```

The conditions for gene labelling can be adjusted by applying different logic in `subset()`. Warnings of the form: `Removed k rows containing missing values (geom_point)` are just indicators that k of the data points are outside either `xlim()` or `ylim()`.


### Z-scoring fold changes
```{r}
library(pheatmap)
sig_results = all_cond[all_cond$padj < 0.01,] #the significantly differentially expressed genes from earlier

#transform lfcs then z-score
rlg = rlog(nb)
rlg_sig = assay(rlg)[rownames(sig_results),]
rlg_z = t(apply(rlg_sig, 1, function(x){ (x - mean(x)) / sd(x)})) #normalize by z-scoring

thr = 2.25
sum(rlg_z > thr)
sum(rlg_z < -thr)
#little data lost from thresholding, but always check! 
#These can also be genes to investigate separately, due to their large scores

rlg_z[rlg_z > thr] = thr
rlg_z[rlg_z < -thr] = -thr
```


### Clustering
``` {r}
#determine number of clusters
library(cluster)

#in this case it is worth performing hierarchical clustering. 
dd = dist(rlg_z)
clusters.hclust = hclust(dd) #you can choose the agglomeration method here, which would change the end results. 

color = c(colorRampPalette(c("dodgerblue2", "white"))(14), colorRampPalette(c("white", "firebrick2"))(14))
breaksList = seq(-thr, thr, length.out = 29)
heat.map <- pheatmap(rlg_z, cluster_col=FALSE, breaks=breaksList, cluster_rows=clusters.hclust, show_rownames=FALSE,color = color,fontsize_row = 3, legend=TRUE,border_color = NA,main = "Hierarchichal clustering", labels_col = c("MUT1_1","MUT1_2","MUT1_3","MUT2_1","MUT2_2", "MUT2_3", "WT1_1", "WT1_3"), angle_col = 45)

#use wss to choose number of clusters
set.seed(123)
k.max <- 15
#1 cluster will almost never be the answer, so we'll leave it out for better visual discrimination
wss <- sapply(2:k.max, 
              function(k){kmeans(rlg_z, k, nstart=10,iter.max = 15 )$tot.withinss})

plot(2:k.max, wss,
     type="b", pch = 19, frame = FALSE, 
     xlab="Number of clusters K",
     ylab="Total within-clusters sum of squares", main = "WSS")
#from wss, I think 5 would be a good value for nclust, based on the elbow method.

#silhouette width to select clusters
SIL = sapply(2:k.max, function(i) {
  results.coef.kmeans =  kmeans(rlg_z, i, nstart=50, iter.max=50)
    mean(silhouette(results.coef.kmeans$cluster, dist(rlg_z))[,3]) })
plot(c(0,SIL), type="b", main = "Silhouette Width")
#silhouette with says use 2 clusters, which is just unreasonable for the data. Small drop from 5 to 6

#k-means with 5 clusters
#clustering
set.seed(123)
nclust = 4
results.coef.kmeans =  kmeans(rlg_z, nclust, nstart=50, iter.max=50)
results.coef = rlg_z[order(results.coef.kmeans$cluster),]
indicator = results.coef.kmeans$cluster[order(results.coef.kmeans$cluster)]

#heatmapping
color = c(colorRampPalette(c("dodgerblue2", "white"))(14), colorRampPalette(c("white", "firebrick2"))(14))
breaksList = seq(-thr, thr, length.out = 29)

heat.map <- pheatmap(results.coef, cluster_col=F, breaks=breaksList, cluster_rows=F, show_rownames=FALSE,color = color,fontsize_row = 3, legend=TRUE, border_color = NA, main =paste("k-means clustering, k =",nclust), labels_col = c("MUT1_1","MUT1_2","MUT1_3","MUT2_1","MUT2_2", "MUT2_3", "WT1_1", "WT1_3"), angle_col = 45)

#cluster sizes
table(results.coef.kmeans$cluster)

```

After performing a z-score normalization on the expression of significant DEGs across all conditions, calculate the WSS and silhouette width for 2 to 15 clusters, to determine the correct number of clusters for the analysis. Combined with hierarchical clustering, k = 4 appears a reasonable choice.


Cluster 1 is up in MUT2, and down in the others.
Cluster 2 is up in WT, down in MUT2, and neutral to slightly up in MUT1.
Cluster 3 is down in MUT2 and up in the others.
Cluster 4 is up in MUT2, and down in the others.
The reason cluster 1 and cluster 4 are distinct is likely the within group variation of MUT2, evident in MUT2_1's z-scores and position on the PCA.

### GO:BP enrichment of clusters
```{r}
library(clusterProfiler)
library(org.Dr.eg.db)
library(stringr)
library(ggplot2)

bp = list()
for (i in 1:nclust) {
  bp[i] = enrichGO(gene          = names(results.coef.kmeans$cluster[results.coef.kmeans$cluster==i]),
                universe      = rownames(nb),
                OrgDb         = org.Dr.eg.db,
                keyType       = 'ENSEMBL',
                ont           = "BP",
                pAdjustMethod = "BH",
                pvalueCutoff  = 1,
                qvalueCutoff  = 0.1,
                readable      = TRUE)
#gene identifiers are ensemble IDs
#orgdb = organism annotation
#ont           = ontology. GO has MF (molecular function), BP (biological process), CC (cellular component).
#universe = all of the genes, after filtering out rRNA/mtRNA and low expression crap
#padj = FDR method
#no pvalue cutoff

}
#ignore the warning messages

#first check if any of the clusters produce no enrichments
head(bp[[1]])
head(bp[[2]])
head(bp[[3]]) # only 2
head(bp[[4]])


#the top 10 terms in the cluster. gene ratio is the number you observe vs expected, like effect size

dotplot(bp[[1]], title = "GO:BP Enrichment of Cluster 1", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40))

dotplot(bp[[2]], title = "GO:BP Enrichment of Cluster 2", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40))

dotplot(bp[[3]], title = "GO:BP Enrichment of Cluster 3", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40))

dotplot(bp[[4]], title = "GO:BP Enrichment of Cluster 4", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40))



```


### GO:MF enrichment of clusters
``` {r}
mf = list()
for (i in 1:nclust) {
  mf[i] = enrichGO(gene          = names(results.coef.kmeans$cluster[results.coef.kmeans$cluster==i]),
                universe      = rownames(nb),
                OrgDb         = org.Dr.eg.db,
                keyType       = 'ENSEMBL',
                ont           = "MF",
                pAdjustMethod = "BH",
                pvalueCutoff  = 1,
                qvalueCutoff  = 0.1,
                readable      = TRUE)
}

head(mf[[1]])
head(mf[[2]])
head(mf[[3]])#no enrichment
head(mf[[4]]) 


dotplot(mf[[1]], title = "GO:MF Enrichment of Cluster 1", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40))

dotplot(mf[[2]], title = "GO:MF Enrichment of Cluster 2", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40))

# dotplot(mf[[3]], title = "GO:MF Enrichment of Cluster 3", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40))

dotplot(mf[[4]], title = "GO:MF Enrichment of Cluster 4", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40))

```


### KEGG enrichment of clusters
``` {r}
kegg = list()
for (i in 1:nclust) {
  kegg[i] = enrichKEGG(gene          = as.character(ensembl.genes[ensembl.genes$gene_id %in% names(results.coef.kmeans$cluster[results.coef.kmeans$cluster==i])]$entrezgene_id),
              universe      = as.character(ensembl.genes[ensembl.genes$gene_id %in% rownames(dds)]$entrezgene_id),
              organism         = "dre",
              qvalueCutoff  = 0.1)

}


head(kegg[[1]])#no enrichment
head(kegg[[2]])
head(kegg[[3]])
head(kegg[[4]]) 


#the top 10 terms in the cluster. gene ratio is the number you observe vs expected, like effect size
# dotplot(kegg[[1]], title = "KEGG Enrichment of Cluster 1", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40))

dotplot(kegg[[2]], title = "KEGG Enrichment of Cluster 2", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40))

dotplot(kegg[[3]], title = "KEGG Enrichment of Cluster 3", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40))

dotplot(kegg[[4]], title = "KEGG Enrichment of Cluster 4", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40))



```

### GO:BP enrichment of pairwise DEGs
[INCOMPLETE]

### Gene set enrichment analysis
``` {r}
library(fgsea)
library(msigdbr)
library(dplyr)
library(gridExtra)

#get gene sets
#msigdbr_species()

#You must select a collection (the category argument). descriptions are on http://www.gsea-msigdb.org/gsea/msigdb/index.jsp
collection = "C7"
d_df = msigdbr(species = "Danio rerio", category = collection)
#length(unique(m_df$gs_name))# number of genesets
fgsea_sets = d_df %>% split(x = .$ensembl_gene, f = .$gs_name) #msigdb now supports ensembl! used to be entrezgene
```
For the moment, we are only looking at MSigDB's hallmark gene sets. From MSigDB: "Hallmark gene sets summarize and represent specific well-defined biological states or processes and display coherent expression. These gene sets were generated by a computational methodology based on identifying gene set overlaps and retaining genes that display coordinate expression. The hallmarks reduce noise and redundancy and provide a better delineated biological space for GSEA. We refer to the original overlapping gene sets, from which a hallmark is derived, as its 'founder' sets. Hallmark gene set pages provide links to the corresponding founder sets for deeper follow up."

All gene set descriptions here: http://www.gsea-msigdb.org/gsea/msigdb/index.jsp

**The most relevant collections for this experiment are C3, or external development related gene sets.**

#### MUT1 vs WT
```{r}
changes = M1_vs_WT #recall that this is before we got significant_results, but after we cleaned and ran negbinom/wald. premise of gsea is that the individual expression changes needn't be significant, so this is what we want to search within.
# sum(ensembl.genes$gene_id %in% row.names(changes)) #the number of genes we matched in the annotation
# changes[!(row.names(changes) %in% ensembl.genes$gene_id),] #the genes in the data we failed to match. They simply do not exist in the annotation. Strange.


ensembl_sub = ensembl.genes[ensembl.genes$gene_id %in% row.names(changes), ] #subset annotation according to overlap
changes_sub = changes[row.names(changes) %in% ensembl.genes$gene_id, ] #subset change data according to overlap

changes_sub = changes_sub[order(row.names(changes_sub)),] #ensure genes are in same order as annotation
sum(ensembl_sub$gene_id == row.names(changes_sub)) #are all gene ids identical?

ensembl_sub$log2FoldChange = changes_sub$log2FoldChange #get corresponding foldchanges

#create vector of fold changes to be ranked by lfc
ensembl_sub_lfc = ensembl_sub$log2FoldChange
names(ensembl_sub_lfc) = ensembl_sub$gene_id

#order by lfc
ensembl_sub_lfc = ensembl_sub_lfc[order(ensembl_sub_lfc, decreasing = T)]
#filter for protein coding genes
ensembl_sub_lfc = ensembl_sub_lfc[names(ensembl_sub_lfc) %in% ensembl_sub$gene_id[ensembl_sub$gene_biotype=="protein_coding"]]
#run gsea
fgseaRes <- fgseaMultilevel(pathways = fgsea_sets, 
                  stats = ensembl_sub_lfc,
                  minSize = 1,
                  maxSize = 500,
                  eps = 0)

#plot
fgseaResTidy = fgseaRes %>% as_tibble() %>% arrange(desc(NES))
fgseaResTidy %>% dplyr::select(-leadingEdge, -ES) %>% arrange(padj) 
ggplot(fgseaResTidy %>% filter(padj < 0.05) %>% head(n= 20), aes(reorder(pathway, NES), NES)) + coord_flip() + geom_col(aes(fill = NES < 2.5)) + labs(x="Term", y="Normalized Enrichment Score", title=paste("GSEA of MUT1 vs WT, on Ontology Gene Set",collection)) + theme_minimal() + scale_y_discrete(labels=function(x) str_wrap(x, width=40))

# #we can also look at a specific term's enrichment
# plotEnrichment(fgsea_sets[["HALLMARK_OXIDATIVE_PHOSPHORYLATION"]], ensembl_sub_lfc) + labs(title="HALLMARK_OXIDATIVE_PHOSPHORYLATION")

```

```{r}
#need a separate chunk or it won't knit properly
#another way to visualize gsea
topPathwaysUp <- fgseaRes[ES > 0][head(order(padj), n=10), pathway]
topPathwaysDown <- fgseaRes[ES < 0][head(order(padj), n=10), pathway]
topPathways <- c(topPathwaysUp, rev(topPathwaysDown))
plotGseaTable(fgsea_sets[topPathways], ensembl_sub_lfc, fgseaRes, gseaParam = 0.5, render = T)
```


#### MUT2 vs WT
```{r}
changes = M2_vs_WT #recall that this is before we got significant_results, but after we cleaned and ran negbinom/wald. premise of gsea is that the individual expression changes needn't be significant, so this is what we want to search within.
# sum(ensembl.genes$gene_id %in% row.names(changes)) #the number of genes we matched in the annotation
# changes[!(row.names(changes) %in% ensembl.genes$gene_id),] #the genes in the data we failed to match. They simply do not exist in the annotation. Strange.


ensembl_sub = ensembl.genes[ensembl.genes$gene_id %in% row.names(changes), ] #subset annotation according to overlap
changes_sub = changes[row.names(changes) %in% ensembl.genes$gene_id, ] #subset change data according to overlap

changes_sub = changes_sub[order(row.names(changes_sub)),] #ensure genes are in same order as annotation
sum(ensembl_sub$gene_id == row.names(changes_sub)) #are all gene ids identical?

ensembl_sub$log2FoldChange = changes_sub$log2FoldChange #get corresponding foldchanges

#create vector of fold changes to be ranked by lfc
ensembl_sub_lfc = ensembl_sub$log2FoldChange
names(ensembl_sub_lfc) = ensembl_sub$gene_id

#order by lfc
ensembl_sub_lfc = ensembl_sub_lfc[order(ensembl_sub_lfc, decreasing = T)]
#filter for protein coding genes
ensembl_sub_lfc = ensembl_sub_lfc[names(ensembl_sub_lfc) %in% ensembl_sub$gene_id[ensembl_sub$gene_biotype=="protein_coding"]]
#run gsea
fgseaRes <- fgseaMultilevel(pathways = fgsea_sets, 
                  stats = ensembl_sub_lfc,
                  minSize = 1,
                  maxSize = 500,
                  eps = 0)

#plot
fgseaResTidy = fgseaRes %>% as_tibble() %>% arrange(desc(NES))
fgseaResTidy %>% dplyr::select(-leadingEdge, -ES) %>% arrange(padj) 
ggplot(fgseaResTidy %>% filter(padj < 0.05) %>% head(n= 20), aes(reorder(pathway, NES), NES)) + coord_flip() + geom_col(aes(fill = NES < 2.5)) + labs(x="Term", y="Normalized Enrichment Score", title=paste("GSEA of MUT2 vs WT, on Ontology Gene Set",collection)) + theme_minimal() + scale_y_discrete(labels=function(x) str_wrap(x, width=40))

```

```{r}
#need a separate chunk or it won't knit properly
#another way to visualize gsea
topPathwaysUp <- fgseaRes[ES > 0][head(order(padj), n=10), pathway]
topPathwaysDown <- fgseaRes[ES < 0][head(order(padj), n=10), pathway]
topPathways <- c(topPathwaysUp, rev(topPathwaysDown))
plotGseaTable(fgsea_sets[topPathways], ensembl_sub_lfc, fgseaRes, gseaParam = 0.5, render = T)
```

[This section needs work. NAs produced.]

#### MUT1 vs MUT2
```{r}
changes = M1_vs_M2 #recall that this is before we got significant_results, but after we cleaned and ran negbinom/wald. premise of gsea is that the individual expression changes needn't be significant, so this is what we want to search within.
# sum(ensembl.genes$gene_id %in% row.names(changes)) #the number of genes we matched in the annotation
# changes[!(row.names(changes) %in% ensembl.genes$gene_id),] #the genes in the data we failed to match. They simply do not exist in the annotation. Strange.


ensembl_sub = ensembl.genes[ensembl.genes$gene_id %in% row.names(changes), ] #subset annotation according to overlap
changes_sub = changes[row.names(changes) %in% ensembl.genes$gene_id, ] #subset change data according to overlap

changes_sub = changes_sub[order(row.names(changes_sub)),] #ensure genes are in same order as annotation
sum(ensembl_sub$gene_id == row.names(changes_sub)) #are all gene ids identical?

ensembl_sub$log2FoldChange = changes_sub$log2FoldChange #get corresponding foldchanges

#create vector of fold changes to be ranked by lfc
ensembl_sub_lfc = ensembl_sub$log2FoldChange
names(ensembl_sub_lfc) = ensembl_sub$gene_id

#order by lfc
ensembl_sub_lfc = ensembl_sub_lfc[order(ensembl_sub_lfc, decreasing = T)]
#filter for protein coding genes
ensembl_sub_lfc = ensembl_sub_lfc[names(ensembl_sub_lfc) %in% ensembl_sub$gene_id[ensembl_sub$gene_biotype=="protein_coding"]]
#run gsea
fgseaRes <- fgseaMultilevel(pathways = fgsea_sets, 
                  stats = ensembl_sub_lfc,
                  minSize = 1,
                  maxSize = 500,
                  eps = 0)

#plot
fgseaResTidy = fgseaRes %>% as_tibble() %>% arrange(desc(NES))
fgseaResTidy %>% dplyr::select(-leadingEdge, -ES) %>% arrange(padj) 
ggplot(fgseaResTidy %>% filter(padj < 0.05) %>% head(n= 20), aes(reorder(pathway, NES), NES)) + coord_flip() + geom_col(aes(fill = NES < 2.5)) + labs(x="Term", y="Normalized Enrichment Score", title=paste("GSEA of MUT1 vs MUT2, on Ontology Gene Set",collection)) + theme_minimal() + scale_y_discrete(labels=function(x) str_wrap(x, width=40))

```

```{r}
#need a separate chunk or it won't knit properly
#another way to visualize gsea
topPathwaysUp <- fgseaRes[ES > 0][head(order(padj), n=10), pathway]
topPathwaysDown <- fgseaRes[ES < 0][head(order(padj), n=10), pathway]
topPathways <- c(topPathwaysUp, rev(topPathwaysDown))
plotGseaTable(fgsea_sets[topPathways], ensembl_sub_lfc, fgseaRes, gseaParam = 0.5, render = T)
```



### END



































