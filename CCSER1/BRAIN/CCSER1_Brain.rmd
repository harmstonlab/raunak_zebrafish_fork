---
title: "CCSER1_Brain"
author: "Raunak Vijayakar"
date: "dd/mm/yyyy"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Notes
From a prior PCA plot, it seems largest variation is between BODY and NON-BODY (BRAIN) samples. All comparisons appear to be within those two groups though, not between. There is some expectation that the effect of CCSER1 knockout in the brain is different from the body. Because the two sets represent different tissues, I will analyze them separately. Otherwise, variation due to cell type would confound any effect due to CCSER1.
BODY appears to have more variance along PC2 than BRAIN, so I will start there.
From the z11_sampleSheet it looks like there are six replicates for all the BRAIN conditions.
CCSER1_S indicates a nonsense mutation (STOP codon) in the gene, and CCSER1_M indicates a missense (different amino acid) mutation in the gene.

## Brain

### Raw counts and annotation
Must delete the first column's name in the txt count data to import gene names as rownames. Ensures the first column (of rownames) is unnamed.
```{r}
library(biomaRt)
library(DESeq2)
library(GenomicFeatures)

brain = read.delim("rawCounts_NON_BODY copy.txt", sep = "")

#exclude any rows where no counts were found for any condition
brain = brain[rowSums(brain) > 0, ]

#take a look at the reads for each condition
barplot(colSums(brain), ylab="Number of aligned reads", las=2, cex.names=0.8)
#numbers are similar across all samples


#get matching annotations
dr.gtf.db <- makeTxDbFromGFF("Danio_rerio.GRCz11.104.chr.gtf", format="gtf")
ensembl.genes = genes(dr.gtf.db)
fish = useEnsembl(biomart="ENSEMBL_MART_ENSEMBL", host = "asia.ensembl.org", dataset="drerio_gene_ensembl", version = "104") #change host as needed
head(listAttributes(fish))#annotations we can request

bm.annotations = getBM(attributes=c("ensembl_gene_id", "entrezgene_id", "gene_biotype", "description", "zfin_id_symbol"), mart=fish, filters="ensembl_gene_id", values=ensembl.genes$gene_id, uniqueRows=TRUE) #error here sometimes, 104 db connection issue??
#also hgnc is so sparse that it could be dropped without consequence

ensembl.genes$zfin_id_symbol = bm.annotations$zfin_id_symbol[ match(ensembl.genes$gene_id, bm.annotations$ensembl_gene_id) ]
ensembl.genes$gene_biotype = bm.annotations$gene_biotype[ match(ensembl.genes$gene_id, bm.annotations$ensembl_gene_id) ]
ensembl.genes$status = bm.annotations$status[ match(ensembl.genes$gene_id, bm.annotations$ensembl_gene_id) ]
ensembl.genes$description = bm.annotations$description[ match(ensembl.genes$gene_id, bm.annotations$ensembl_gene_id) ]
ensembl.genes$entrezgene_id = bm.annotations$entrezgene_id[ match(ensembl.genes$gene_id, bm.annotations$ensembl_gene_id) ]
```

After reading in the quantified data as read counts, filter out any genes that are not expressed in any sample. Check the read depth of each sample with a barplot. Read depth is quite consistent in this data. Find annotations corresponding to each gene.



### DDS and Filtering

```{r}
#see how many reads are in rRNA/mtRNA
rrna = names(ensembl.genes[ensembl.genes$gene_biotype %in% c("Mt_rRNA", "rRNA" )])
total.rrna = colSums(brain[row.names(brain) %in% rrna,])
barplot(100 * (total.rrna / colSums(brain)), ylab="%rRNA/mtRNA", las=2, cex.names=0.8)

#how many reads are in mitochondrial chromosome?
chrM = names(ensembl.genes[ensembl.genes@seqnames %in% "MT", ])
total.mchrom = colSums(brain[row.names(brain) %in% chrM,])
barplot(100 * (total.mchrom / colSums(brain)), ylab="%MT", las=2, cex.names=0.8)


#remove rRNA and mtRNA
brain = brain[!(row.names(brain) %in% rrna),]
# #remove mitochondrial chromosome reads
# brain = brain[!(row.names(brain) %in% chrM),]


met = read.csv("brain_metadata.csv") #sample ids and conditions. no batch indicator, so we won't be controlling for that.

dds = DESeqDataSetFromMatrix(brain, met, ~ condition)

dds

dds <- estimateSizeFactors(dds)
dds <- estimateDispersions(dds) #this helps us deal w/fact that we don't have 30 samples/condition

#normalize for read depth
head(counts(dds))
head(counts(dds, normalized=TRUE)) #can do this because we called sizefactors b/f, these number can be compared directly, across condition, not across gene though

#only choosing genes that have a normalized mean expression across conditions >= 10. This removes lowly expressed genes that are hard to differentiate from noise. could also be done after examining p-value histogram of a significance test, comparing pre- and post-filtering.
filter = apply(counts(dds, normalized=TRUE), 1, function(x){ mean(x) >= 10 })
dds = dds[filter, ]


#apply regularized log transform. 
rld <- rlog(dds)



```

Check for rRNA, and mt rRNA. Ideally these reads will be filtered out during the sequencing process (using ribozero, etc.). The barplots show that the sequencing is already well depleted for both of these sources of noise, as the percentages for both are low. Regardless, remove any genes annotated to be either rRNA, or mtRNA. Filter out genes that are lowly expressed (mean expression < 10), and apply a regularized log transform for PCA, normalizing for library size and putting the count data on a log2 scale.


### PCA
``` {r}
#do PCA
plotPCA(rld, intgroup = c( "condition"))
plotPCA(rld, intgroup = c( "sample_id"))
#separates the conditions from each other, which is what we hope. There's large variance between replicates, but that's okay since the replicates cross conditions.


```
Perform PCA to both visualize the high dimensional RNASeq data, and to see if samples are well separated. 

### Differential expression analysis
```{r}
#all_cond
#since condition is the only contrast, reduced model won't be controlling for sex, batch, etc.
nb = nbinomLRT(dds, full = design(dds), reduced = ~1)
all_cond = results(nb)
hist(all_cond$pvalue)
#though the listed foldchange is calculated for some pair of conditions, the p-value from nbinomlrt is for all conditions.

sum(is.na(all_cond$padj)) #141 genes have NA p-values and padj
#all_cond[is.na(all_cond$padj),] #interesting that 2 are interferon involved (ifi/ifit). One is a lincRNA.

#explanation from DESeq2 vignette:
# If a row contains a sample with an extreme count outlier then the p value and adjusted p value will be set to NA. These outlier counts are detected by Cookâ€™s distance.

#For now I will remove these genes and move on, but they might deserve another look
all_cond = all_cond[!is.na(all_cond$padj),]

#significance level of 0.01 for FDR. this is a cutoff for the expected false positive rate (proportion of DEGs that were false to total DEGs). since we have a lot of genes, this seems like a reasonable alpha.
sum(all_cond$padj < 0.01)

#S_vs_WT
S_vs_WT = results(nb, contrast=c("condition", "CCSER1_S", "WT"), independentFiltering = TRUE, alpha=0.1, test="Wald")
hist(S_vs_WT$pvalue) #check this to ensure there isn't batch effect, and that we filtered out the low read genes. Though we can't control for batch in this case.
S_vs_WT = S_vs_WT[!is.na(S_vs_WT$padj),] #remove NAs
sum(S_vs_WT$padj < 0.01)


#M_vs_WT
M_vs_WT = results(nb, contrast=c("condition", "CCSER1_M", "WT"), independentFiltering = TRUE, alpha=0.1, test="Wald")
hist(M_vs_WT$pvalue)
M_vs_WT = M_vs_WT[!is.na(M_vs_WT$padj),] #remove NAs
sum(M_vs_WT$padj < 0.01)


#Would it make sense to also compare pairwise between the mutants? Possibly.
M_vs_S = results(nb, contrast=c("condition", "CCSER1_M", "CCSER1_S"), independentFiltering = TRUE, alpha=0.1, test="Wald")
hist(M_vs_S$pvalue)
M_vs_S = M_vs_S[!is.na(M_vs_S$padj),] #remove NAs
sum(M_vs_S$padj < 0.01)

```


To compare expression across all conditions, use the negative binomial likelihood ratio test (nbinomLRT). This is analogous to ANOVA, and allows the comparison of more than two groups. For the pairwise comparisons, a Wald test is used, though nbinomLRT would also be acceptable. It is easier here to use Wald, as it means you do not need to subset `dds`. Check for genes containing `NA` in `padj`. For all tests, set the FDR cutoff for significance at 0.01, since there are many genes being tested. Across all conditions, there are **2656** significant DEGs. **1327** for CCSER1_S vs WT, **1341** for CCSER1_M vs WT, and **1343** for CCSER1_M vs CCSER1_S. Also check the histogram of p-values for all tests to ensure we do not observe batch effects.

#### Examine CCSER1 expression
```{r}
S_vs_WT[row.names(S_vs_WT) == "ENSDARG00000075919",] 
M_vs_WT[row.names(M_vs_WT) == "ENSDARG00000075919",] 

```

Negative log2fc for CCSER1_M with respect to wild type. Not padj < 0.01 however.

### MA and volcano plots
```{r}
library(scales)

#S_vs_WT
plot(S_vs_WT$log2FoldChange, -log10(S_vs_WT$padj), xlim = c(-15, 15), col = alpha("dodgerblue",0.5), main = "Volcano, CCSER1_S vs WT")
abline(h = 2, v = c(-2,2)) #p = 0.01 and lfc = +/- 2

plotMA(S_vs_WT, ylim=c(-15,15), main = "MA Plot, CCSER1_S vs WT")

#M_vs_WT
plot(M_vs_WT$log2FoldChange, -log10(M_vs_WT$padj), xlim = c(-15, 15), col = alpha("seagreen",0.5), main = "Volcano, CCSER1_M vs WT")
abline(h = 2, v = c(-2,2)) #p = 0.01 and lfc = +/- 2

plotMA(M_vs_WT, ylim=c(-15,15), main = "MA Plot, CCSER1_M vs WT")

#M_vs_S
plot(M_vs_S$log2FoldChange, -log10(M_vs_S$padj), xlim = c(-15, 15), col = alpha("firebrick",0.5), main = "Volcano, CCSER1_M vs CCSER1_S")
abline(h = 2, v = c(-2,2)) #p = 0.01 and lfc = +/- 2

plotMA(M_vs_S, ylim=c(-15,15), main = "MA Plot, CCSER1_M vs CCSER1_S")

```

Produce MA and volcano plots for the pairwise comparisons. MA plots show the difference in gene expression (log fold change) between two conditions, relative to the mean expression across those conditions. Each point represents a particular gene. A gene with a similar expression level in both conditions will be near y = 0. Being further from y = 0 indicates up/down regulation. To compare along the x-axis: For a typically lowly expressed gene (low mean count), there is lower statistical power for an observed expression difference than a highly expressed gene (high A). MA plots tend to have even dispersion relative to the y-axis, which then decreases as x increases. Grey points indicate non-significant data points.

Volcano plots compare adjusted p-value and log fold change. Here I use -log10(adjusted p-value) and log2(fold change). Again, each point represents a gene. The higher on the y-axis, the smaller the adjusted p-value. The more extreme the value on the x-axis, the greater the difference in expression levels across conditions. A greater dispersion means that the two groups have greater differences in gene expression.

Both the MA plots show regulation changes between the mutants and wild type. Note that they also show a greater degree of downregulation than upregulation, which is also evident in the volcano plots. It is especially pronounced in CCSER1_M (the foldchange looks greater).

These plots also allow us to see if any changes are particularly significant or large, so we can investigate those genes individually.

#### Identifying specific genes from volcano plots [WIP]
```{r}
library(ggrepel)

#S vs WT
S_vs_WT_d = as.data.frame(S_vs_WT)
S_vs_WT_d$name = row.names(S_vs_WT_d)

ggplot(S_vs_WT_d, aes(x = log2FoldChange, y = -log10(padj), label=name)) + geom_point(alpha = 0.5, color = "dodgerblue") + labs(title = "Volcano, CCSER1_S vs WT") + geom_text_repel(data = subset(S_vs_WT_d, -log10(padj) > 40), size = 3)

#M vs WT
M_vs_WT_d = as.data.frame(M_vs_WT)
M_vs_WT_d$name = row.names(M_vs_WT_d)

ggplot(M_vs_WT_d, aes(x = log2FoldChange, y = -log10(padj), label=name)) + geom_point(alpha = 0.5, color = "seagreen") + labs(title = "Volcano, CCSER1_M vs WT") + geom_text_repel(data = subset(M_vs_WT_d, -log10(padj) > 30), size = 3)

#M vs S
M_vs_S_d = as.data.frame(M_vs_S)
M_vs_S_d$name = row.names(M_vs_S_d)

ggplot(M_vs_S_d, aes(x = log2FoldChange, y = -log10(padj), label=name)) + geom_point(alpha = 0.5, color = "firebrick") + labs(title = "Volcano, CCSER1_M vs CCSER1_S") + geom_text_repel(data = subset(M_vs_S_d, -log10(padj) > 30), size = 3)
```

The conditions for gene labelling can be adjusted by applying different logic in `subset()`. Warnings of the form: `Removed k rows containing missing values (geom_point)` are just indicators that k of the data points are outside either `xlim()` or `ylim()`.


### Z-scoring fold changes
```{r}
library(pheatmap)
sig_results = all_cond[all_cond$padj < 0.01,] #the significantly differentially expressed genes from earlier

#transform lfcs then z-score
rlg = rlog(nb)
rlg_sig = assay(rlg)[rownames(sig_results),]
rlg_z = t(apply(rlg_sig, 1, function(x){ (x - mean(x)) / sd(x)})) #normalize by z-scoring

thr = 2.5
sum(rlg_z > thr)
sum(rlg_z < -thr)
#little data lost from thresholding, but always check! 
#These can also be genes to investigate separately, due to their large scores

rlg_z[rlg_z > thr] = thr
rlg_z[rlg_z < -thr] = -thr
```


### K-means clustering
``` {r}
#determine number of clusters
library(cluster)

#use wss to choose number of clusters
set.seed(123)
k.max <- 15
#1 cluster will almost never be the answer, so we'll leave it out for better visual discrimination
wss <- sapply(2:k.max, 
              function(k){kmeans(rlg_z, k, nstart=10,iter.max = 15 )$tot.withinss})

plot(2:k.max, wss,
     type="b", pch = 19, frame = FALSE, 
     xlab="Number of clusters K",
     ylab="Total within-clusters sum of squares", main = "WSS")
#from wss, I think 5 would be a good value for nclust, based on the elbow method.

#silhouette width to select clusters
SIL = sapply(2:k.max, function(i) {
  results.coef.kmeans =  kmeans(rlg_z, i, nstart=50, iter.max=50)
    mean(silhouette(results.coef.kmeans$cluster, dist(rlg_z))[,3]) })
plot(c(0,SIL), type="b", main = "Silhouette Width")
#silhouette with says use 3 clusters, which is just unreasonable for the data. Confirms that 5 is a reasonable choice. width drops sharply after 5.

#k-means with 4 clusters
#clustering
set.seed(123)
nclust = 4
results.coef.kmeans =  kmeans(rlg_z, nclust, nstart=50, iter.max=50)
results.coef = rlg_z[order(results.coef.kmeans$cluster),]
indicator = results.coef.kmeans$cluster[order(results.coef.kmeans$cluster)]

#heatmapping
color = c(colorRampPalette(c("dodgerblue2", "white"))(14), colorRampPalette(c("white", "firebrick2"))(14))
breaksList = seq(-thr, thr, length.out = 29)

heat.map <- pheatmap(results.coef, cluster_col=F, breaks=breaksList, cluster_rows=F, cluster_cols = F, show_rownames=FALSE,color = color,fontsize_row = 3, legend=TRUE,border_color = NA,
                     main = paste("k-means clustering, k =", nclust), angle_col = 45)

#cluster sizes
table(results.coef.kmeans$cluster)

```

After performing a z-score normalization on the expression of significant DEGs across all conditions, calculate the WSS and silhouette width for 2 to 15 clusters, to determine the correct number of clusters for the analysis. Combining the results of both statistics, k = 5 would be a reasonable choice, and then perform the clustering.

Cluster 1 is down in the mutants, and up in the wt.
Cluster 2 is up in the mutants, and down in the wt.
Cluster 3 is down in missense, and up in others.
Cluster 4 is up in missense, down in nonsense/stop, and mixed in the wt.

### GO:BP enrichment of clusters
```{r}
library(clusterProfiler)
library(org.Dr.eg.db)
library(stringr)
library(ggplot2)

bp = list()
for (i in 1:nclust) {
  bp[i] = enrichGO(gene          = names(results.coef.kmeans$cluster[results.coef.kmeans$cluster==i]),
                universe      = rownames(nb),
                OrgDb         = org.Dr.eg.db,
                keyType       = 'ENSEMBL',
                ont           = "BP",
                pAdjustMethod = "BH",
                pvalueCutoff  = 1,
                qvalueCutoff  = 0.1,
                readable      = TRUE)
#gene identifiers are ensemble IDs
#orgdb = organism annotation
#ont           = ontology. GO has MF (molecular function), BP (biological process), CC (cellular component).
#universe = all of the genes, after filtering out rRNA/mtRNA and low expression crap
#padj = FDR method
#no pvalue cutoff

}
#ignore the warning messages

#first check if any of the clusters produce no enrichments
# head(bp[[1]])
# head(bp[[2]])
# head(bp[[3]])
# head(bp[[4]])
# head(bp[[5]])


#the top 10 terms in the cluster. gene ratio is the number you observe vs expected, like effect size

dotplot(bp[[1]], title = "GO:BP Enrichment of Cluster 1", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40))

dotplot(bp[[2]], title = "GO:BP Enrichment of Cluster 2", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40))

dotplot(bp[[3]], title = "GO:BP Enrichment of Cluster 3", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40))

dotplot(bp[[4]], title = "GO:BP Enrichment of Cluster 4", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40))

# dotplot(bp[[5]], title = "GO:BP Enrichment of Cluster 5", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40))


```



### GO:MF enrichment of clusters
``` {r}
mf = list()
for (i in 1:nclust) {
  mf[i] = enrichGO(gene          = names(results.coef.kmeans$cluster[results.coef.kmeans$cluster==i]),
                universe      = rownames(nb),
                OrgDb         = org.Dr.eg.db,
                keyType       = 'ENSEMBL',
                ont           = "MF",
                pAdjustMethod = "BH",
                pvalueCutoff  = 1,
                qvalueCutoff  = 0.1,
                readable      = TRUE)
}

# head(mf[[1]])
# head(mf[[2]])
# head(mf[[3]])
# head(mf[[4]])
# head(mf[[5]])


dotplot(mf[[1]], title = "GO:MF Enrichment of Cluster 1", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40))

dotplot(mf[[2]], title = "GO:MF Enrichment of Cluster 2", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40))

dotplot(mf[[3]], title = "GO:MF Enrichment of Cluster 3", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40))

dotplot(mf[[4]], title = "GO:MF Enrichment of Cluster 4", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40))

# dotplot(mf[[5]], title = "GO:MF Enrichment of Cluster 5", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40))
```


### KEGG enrichment of clusters
``` {r}
kegg = list()
for (i in 1:nclust) {
  kegg[i] = enrichKEGG(gene          = as.character(ensembl.genes[ensembl.genes$gene_id %in% names(results.coef.kmeans$cluster[results.coef.kmeans$cluster==i])]$entrezgene_id),
              universe      = as.character(ensembl.genes[ensembl.genes$gene_id %in% rownames(nb)]$entrezgene_id),
              organism         = "dre",
              qvalueCutoff  = 0.1)

}


# head(kegg[[1]])
# head(kegg[[2]])
# head(kegg[[3]])
# head(kegg[[4]]) 
# head(kegg[[5]])


#the top 10 terms in the cluster. gene ratio is the number you observe vs expected, like effect size
dotplot(kegg[[1]], title = "KEGG Enrichment of Cluster 1", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40))

dotplot(kegg[[2]], title = "KEGG Enrichment of Cluster 2", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40))

dotplot(kegg[[3]], title = "KEGG Enrichment of Cluster 3", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40))

dotplot(kegg[[4]], title = "KEGG Enrichment of Cluster 4", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40))

# dotplot(kegg[[5]], title = "KEGG Enrichment of Cluster 5", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40))


```



### GO:BP enrichment of pairwise DEGs
```{r}
swt_sig = S_vs_WT[S_vs_WT$padj < 0.01,]
swt_bp = enrichGO(gene          = rownames(swt_sig),
                universe      = rownames(nb),
                OrgDb         = org.Dr.eg.db,
                keyType       = 'ENSEMBL',
                ont           = "BP",
                pAdjustMethod = "BH",
                pvalueCutoff  = 1,
                qvalueCutoff  = 0.1,
                readable      = TRUE)

# head(swt_bp)
dotplot(swt_bp, title = "GO:BP enrichment of differentially expressed genes (CCSER1_S vs WT)", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40))


mwt_sig = M_vs_WT[M_vs_WT$padj < 0.01,]
mwt_bp = enrichGO(gene          = rownames(mwt_sig),
                universe      = rownames(nb),
                OrgDb         = org.Dr.eg.db,
                keyType       = 'ENSEMBL',
                ont           = "BP",
                pAdjustMethod = "BH",
                pvalueCutoff  = 1,
                qvalueCutoff  = 0.1,
                readable      = TRUE)

# head(mwt_bp)
dotplot(mwt_bp, title = "GO:BP enrichment of differentially expressed genes (CCSER1_M vs WT)", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40))


ms_sig = M_vs_S[M_vs_S$padj < 0.01,]
ms_bp = enrichGO(gene          = rownames(ms_sig),
                universe      = rownames(nb),
                OrgDb         = org.Dr.eg.db,
                keyType       = 'ENSEMBL',
                ont           = "BP",
                pAdjustMethod = "BH",
                pvalueCutoff  = 1,
                qvalueCutoff  = 0.1,
                readable      = TRUE)

# head(ms_bp)
dotplot(ms_bp, title = "GO:BP enrichment of differentially expressed genes (CCSER1_M vs CCSER1_S)", font.size = 10) + scale_y_discrete(labels=function(x) str_wrap(x, width=40)) 

```


### Gene set enrichment analysis
``` {r}
library(fgsea)
library(msigdbr)
library(dplyr)
library(gridExtra)

#get gene sets
#msigdbr_species()

#You must select a collection (the category argument). descriptions are on http://www.gsea-msigdb.org/gsea/msigdb/index.jsp
collection = "C2"
d_df = msigdbr(species = "Danio rerio", category = collection)
#length(unique(m_df$gs_name))# number of genesets
fgsea_sets = d_df %>% split(x = .$ensembl_gene, f = .$gs_name) #msigdb now supports ensembl! used to be entrezgene
```
For the moment, we are only looking at MSigDB's hallmark gene sets. From MSigDB: "Hallmark gene sets summarize and represent specific well-defined biological states or processes and display coherent expression. These gene sets were generated by a computational methodology based on identifying gene set overlaps and retaining genes that display coordinate expression. The hallmarks reduce noise and redundancy and provide a better delineated biological space for GSEA. We refer to the original overlapping gene sets, from which a hallmark is derived, as its 'founder' sets. Hallmark gene set pages provide links to the corresponding founder sets for deeper follow up."

All gene set descriptions here: http://www.gsea-msigdb.org/gsea/msigdb/index.jsp

**The most relevant collections for this experiment are ???**

#### CCSER1_S vs WT
```{r}
changes = S_vs_WT #recall that this is before we got significant_results, but after we cleaned and ran negbinom/wald. premise of gsea is that the individual expression changes needn't be significant, so this is what we want to search within.
# sum(ensembl.genes$gene_id %in% row.names(changes)) #the number of genes we matched in the annotation
# changes[!(row.names(changes) %in% ensembl.genes$gene_id),] #the genes in the data we failed to match. They simply do not exist in the annotation. Strange.


ensembl_sub = ensembl.genes[ensembl.genes$gene_id %in% row.names(changes), ] #subset annotation according to overlap
changes_sub = changes[row.names(changes) %in% ensembl.genes$gene_id, ] #subset change data according to overlap
sum(ensembl_sub$gene_id == row.names(changes_sub)) #all gene ids identical

ensembl_sub$log2FoldChange = changes_sub$log2FoldChange #get corresponding foldchanges

#create vector of fold changes to be ranked by lfc
ensembl_sub_lfc = ensembl_sub$log2FoldChange
names(ensembl_sub_lfc) = ensembl_sub$gene_id

#order by lfc
ensembl_sub_lfc = ensembl_sub_lfc[order(ensembl_sub_lfc, decreasing = T)]
#filter for protein coding genes
ensembl_sub_lfc = ensembl_sub_lfc[names(ensembl_sub_lfc) %in% ensembl_sub$gene_id[ensembl_sub$gene_biotype=="protein_coding"]]
#run gsea
fgseaRes <- fgseaMultilevel(pathways = fgsea_sets, 
                  stats = ensembl_sub_lfc,
                  minSize = 1,
                  maxSize = 500,
                  eps = 0)

#plot
fgseaResTidy = fgseaRes %>% as_tibble() %>% arrange(desc(NES))
fgseaResTidy %>% dplyr::select(-leadingEdge, -ES) %>% arrange(padj) 
ggplot(fgseaResTidy %>% filter(padj < 0.05) %>% head(n= 20), aes(reorder(pathway, NES), NES)) + coord_flip() + geom_col(aes(fill = NES < 2.5)) + labs(x="Term", y="Normalized Enrichment Score", title=paste(collection, "GSEA of CCSER1_S vs WT")) + theme_minimal() + scale_y_discrete(labels=function(x) str_wrap(x, width=40))

#we can also look at a specific term's enrichment
# plotEnrichment(fgsea_sets[["HALLMARK_OXIDATIVE_PHOSPHORYLATION"]], ensembl_sub_lfc) + labs(title="HALLMARK_OXIDATIVE_PHOSPHORYLATION")
```

```{r}
#need a separate chunk or it won't knit properly
#another way to visualize gsea
topPathwaysUp <- fgseaRes[ES > 0][head(order(padj), n=10), pathway]
topPathwaysDown <- fgseaRes[ES < 0][head(order(padj), n=10), pathway]
topPathways <- c(topPathwaysUp, rev(topPathwaysDown))
plotGseaTable(fgsea_sets[topPathways], ensembl_sub_lfc, fgseaRes, gseaParam = 0.5, render = T)
```


#### CCSER1_M vs WT
```{r}
changes = M_vs_WT #recall that this is before we got significant_results, but after we cleaned and ran negbinom/wald. premise of gsea is that the individual expression changes needn't be significant, so this is what we want to search within.

# sum(ensembl.genes$gene_id %in% row.names(changes)) #the number of genes we matched in the annotation
# changes[!(row.names(changes) %in% ensembl.genes$gene_id),] #the genes in the data we failed to match. They simply do not exist in the annotation. Strange.


ensembl_sub = ensembl.genes[ensembl.genes$gene_id %in% row.names(changes), ] #subset annotation according to overlap
changes_sub = changes[row.names(changes) %in% ensembl.genes$gene_id, ] #subset change data according to overlap
sum(ensembl_sub$gene_id == row.names(changes_sub)) #all gene ids identical

ensembl_sub$log2FoldChange = changes_sub$log2FoldChange #get corresponding foldchanges

#create vector of fold changes to be ranked by lfc
ensembl_sub_lfc = ensembl_sub$log2FoldChange
names(ensembl_sub_lfc) = ensembl_sub$gene_id

#order by lfc
ensembl_sub_lfc = ensembl_sub_lfc[order(ensembl_sub_lfc, decreasing = T)]
#filter for protein coding genes
ensembl_sub_lfc = ensembl_sub_lfc[names(ensembl_sub_lfc) %in% ensembl_sub$gene_id[ensembl_sub$gene_biotype=="protein_coding"]]
#run gsea
fgseaRes <- fgseaMultilevel(pathways = fgsea_sets, 
                  stats = ensembl_sub_lfc,
                  minSize = 1,
                  maxSize = 500,
                  eps = 0)

#plot
fgseaResTidy = fgseaRes %>% as_tibble() %>% arrange(desc(NES))
fgseaResTidy %>% dplyr::select(-leadingEdge, -ES) %>% arrange(padj) 
ggplot(fgseaResTidy %>% filter(padj < 0.05) %>% head(n= 20), aes(reorder(pathway, NES), NES)) + coord_flip() + geom_col(aes(fill = NES < 2.5)) + labs(x="Term", y="Normalized Enrichment Score", title=paste(collection, "GSEA of CCSER1_M vs WT")) + theme_minimal() + scale_y_discrete(labels=function(x) str_wrap(x, width=40))

```

```{r}
topPathwaysUp <- fgseaRes[ES > 0][head(order(padj), n=10), pathway]
topPathwaysDown <- fgseaRes[ES < 0][head(order(padj), n=10), pathway]
topPathways <- c(topPathwaysUp, rev(topPathwaysDown))
plotGseaTable(fgsea_sets[topPathways], ensembl_sub_lfc, fgseaRes, gseaParam = 0.5, render = T)
```


#### CCSER1_M vs CCSER1_S
```{r}
changes = M_vs_S #recall that this is before we got significant_results, but after we cleaned and ran negbinom/wald. premise of gsea is that the individual expression changes needn't be significant, so this is what we want to search within.

# sum(ensembl.genes$gene_id %in% row.names(changes)) #the number of genes we matched in the annotation
# changes[!(row.names(changes) %in% ensembl.genes$gene_id),] #the genes in the data we failed to match. They simply do not exist in the annotation. Strange.


ensembl_sub = ensembl.genes[ensembl.genes$gene_id %in% row.names(changes), ] #subset annotation according to overlap
changes_sub = changes[row.names(changes) %in% ensembl.genes$gene_id, ] #subset change data according to overlap
sum(ensembl_sub$gene_id == row.names(changes_sub)) #all gene ids identical

ensembl_sub$log2FoldChange = changes_sub$log2FoldChange #get corresponding foldchanges

#create vector of fold changes to be ranked by lfc
ensembl_sub_lfc = ensembl_sub$log2FoldChange
names(ensembl_sub_lfc) = ensembl_sub$gene_id

#order by lfc
ensembl_sub_lfc = ensembl_sub_lfc[order(ensembl_sub_lfc, decreasing = T)]
#filter for protein coding genes
ensembl_sub_lfc = ensembl_sub_lfc[names(ensembl_sub_lfc) %in% ensembl_sub$gene_id[ensembl_sub$gene_biotype=="protein_coding"]]
#run gsea
fgseaRes <- fgseaMultilevel(pathways = fgsea_sets, 
                  stats = ensembl_sub_lfc,
                  minSize = 1,
                  maxSize = 500,
                  eps = 0)

#plot
fgseaResTidy = fgseaRes %>% as_tibble() %>% arrange(desc(NES))
fgseaResTidy %>% dplyr::select(-leadingEdge, -ES) %>% arrange(padj) 
ggplot(fgseaResTidy %>% filter(padj < 0.05) %>% head(n= 20), aes(reorder(pathway, NES), NES)) + coord_flip() + geom_col(aes(fill = NES < 2.5)) + labs(x="Term", y="Normalized Enrichment Score", title=paste(collection, "GSEA of CCSER1_M vs CCSER1_S")) + theme_minimal() + scale_y_discrete(labels=function(x) str_wrap(x, width=40))
```

```{r}
topPathwaysUp <- fgseaRes[ES > 0][head(order(padj), n=10), pathway]
topPathwaysDown <- fgseaRes[ES < 0][head(order(padj), n=10), pathway]
topPathways <- c(topPathwaysUp, rev(topPathwaysDown))
plotGseaTable(fgsea_sets[topPathways], ensembl_sub_lfc, fgseaRes, gseaParam = 0.5, render = T)
```

### Custom GSEA
```{r}
# pathways = gmtPathways("HuGSEA.txt")
# set1 = sapply(pathways, tolower) #lowercase everything for zfin
# set2 = paste(set1, "a", sep = "") #add the a genome duplicate
# set3 = paste(set1, "b", sep = "") #add the b genome duplicate
# set4 = substr(set1,1,nchar(set1)-1) #no duplicate
# #the idea is to cast a wide enough net to catch all the desired genes (that exist in the annotation), but not so wide as to pick up others.
# combined = c(set1, set2, set3, set4)
# 
# #naive search
# search1 = ensembl.genes[ensembl.genes$zfin_id_symbol %in% set1, ]
# 
# #expanded search
# search2 = ensembl.genes[ensembl.genes$zfin_id_symbol %in% combined, ]
# 
# # #the disjunction
# # dis = search2[!(search2$zfin_id_symbol %in% search1$zfin_id_symbol), ]
# 
# #recreate gsea set, with zebrafish ensembl gene ids
# paths = list(search2$gene_id)
# names(paths) = "Alcoholism" #adjust as needed for multiple pathways. bit of a bodge.
# paths

```
Obsolete method. Use below.

```{r}
pathways = gmtPathways("HuGSEA.txt")
lookup = read.csv("human_zebrafish_hcop_fifteen_column.txt", sep = "\t")
setname = "Hu et al. (2018)"

length(unique(lookup$zebrafish_ensembl_gene)) #number of unique orthologs in the entire hcop table
#compare with ensembl: 25592 coding genes in the zebrafish primary assembly.

paths = list()
for (i in 1:length(pathways)) {
  paths[[i]] = lookup[lookup$human_symbol %in% pathways[[i]], 9]
  paths[[i]] = paths[[i]][nchar(paths[[i]]) == 18]
  paths[[i]] = unique(paths[[i]])
}

names(paths) = names(pathways) #adjust as needed for multiple pathways

sapply(paths, length)
```

Using data from Table 1 in "Analyzing the genes related to nicotine addiction or schizophrenia via a pathway and network based approach" by Hu et al. (2018).

#### CCSER1_S vs WT
``` {r}
changes = S_vs_WT 

ensembl_sub = ensembl.genes[ensembl.genes$gene_id %in% row.names(changes), ] #subset annotation according to overlap
changes_sub = changes[row.names(changes) %in% ensembl.genes$gene_id, ] #subset change data according to overlap
sum(ensembl_sub$gene_id == row.names(changes_sub)) #all gene ids identical

ensembl_sub$log2FoldChange = changes_sub$log2FoldChange #get corresponding foldchanges

#create vector of fold changes to be ranked by lfc
ensembl_sub_lfc = ensembl_sub$log2FoldChange
names(ensembl_sub_lfc) = ensembl_sub$gene_id

#order by lfc
ensembl_sub_lfc = ensembl_sub_lfc[order(ensembl_sub_lfc, decreasing = T)]
#filter for protein coding genes
ensembl_sub_lfc = ensembl_sub_lfc[names(ensembl_sub_lfc) %in% ensembl_sub$gene_id[ensembl_sub$gene_biotype=="protein_coding"]]

fgseaRes <- fgseaMultilevel(pathways = paths, 
                  stats = ensembl_sub_lfc,
                  minSize = 1,
                  maxSize = 500,
                  eps = 0)
head(fgseaRes)
plotEnrichment(paths[["Alcoholism"]], ensembl_sub_lfc) + labs(title="Alcoholism") #check pathway names VERY carefully

```

For an explanation of why the p-value and padj can be the same, see nominal p-value on this site: https://www.gsea-msigdb.org/gsea/doc/GSEAUserGuideFrame.html

```{r}
#plot
fgseaResTidy = fgseaRes %>% as_tibble() %>% arrange(desc(NES))
fgseaResTidy %>% dplyr::select(-leadingEdge, -ES) %>% arrange(padj) 
ggplot(fgseaResTidy %>% filter(padj < 0.05) %>% head(n= 20), aes(reorder(pathway, NES), NES)) + coord_flip() + geom_col(aes(fill = NES < 2.5)) + labs(x="Term", y="Normalized Enrichment Score", title=paste("GSEA of CCSER1_S vs WT, on Custom Gene Set:",setname)) + theme_minimal() + scale_y_discrete(labels=function(x) str_wrap(x, width=40))
```



#### CCSER1_M vs WT
``` {r}
changes = M_vs_WT 

ensembl_sub = ensembl.genes[ensembl.genes$gene_id %in% row.names(changes), ] #subset annotation according to overlap
changes_sub = changes[row.names(changes) %in% ensembl.genes$gene_id, ] #subset change data according to overlap
sum(ensembl_sub$gene_id == row.names(changes_sub)) #all gene ids identical

ensembl_sub$log2FoldChange = changes_sub$log2FoldChange #get corresponding foldchanges

#create vector of fold changes to be ranked by lfc
ensembl_sub_lfc = ensembl_sub$log2FoldChange
names(ensembl_sub_lfc) = ensembl_sub$gene_id

#order by lfc
ensembl_sub_lfc = ensembl_sub_lfc[order(ensembl_sub_lfc, decreasing = T)]
#filter for protein coding genes
ensembl_sub_lfc = ensembl_sub_lfc[names(ensembl_sub_lfc) %in% ensembl_sub$gene_id[ensembl_sub$gene_biotype=="protein_coding"]]

fgseaRes <- fgseaMultilevel(pathways = paths, 
                  stats = ensembl_sub_lfc,
                  minSize = 1,
                  maxSize = 500,
                  eps = 0)
head(fgseaRes)
plotEnrichment(paths[["Alcoholism"]], ensembl_sub_lfc) + labs(title="Alcoholism") #check pathway names VERY carefully

```



```{r}
#plot
fgseaResTidy = fgseaRes %>% as_tibble() %>% arrange(desc(NES))
fgseaResTidy %>% dplyr::select(-leadingEdge, -ES) %>% arrange(padj) 
```


#### CCSER1_M vs CCSER1_S
``` {r}
changes = M_vs_S

ensembl_sub = ensembl.genes[ensembl.genes$gene_id %in% row.names(changes), ] #subset annotation according to overlap
changes_sub = changes[row.names(changes) %in% ensembl.genes$gene_id, ] #subset change data according to overlap
sum(ensembl_sub$gene_id == row.names(changes_sub)) #all gene ids identical

ensembl_sub$log2FoldChange = changes_sub$log2FoldChange #get corresponding foldchanges

#create vector of fold changes to be ranked by lfc
ensembl_sub_lfc = ensembl_sub$log2FoldChange
names(ensembl_sub_lfc) = ensembl_sub$gene_id

#order by lfc
ensembl_sub_lfc = ensembl_sub_lfc[order(ensembl_sub_lfc, decreasing = T)]
#filter for protein coding genes
ensembl_sub_lfc = ensembl_sub_lfc[names(ensembl_sub_lfc) %in% ensembl_sub$gene_id[ensembl_sub$gene_biotype=="protein_coding"]]

fgseaRes <- fgseaMultilevel(pathways = paths, 
                  stats = ensembl_sub_lfc,
                  minSize = 1,
                  maxSize = 500,
                  eps = 0)
head(fgseaRes)
plotEnrichment(paths[["Alcoholism"]], ensembl_sub_lfc) + labs(title="Alcoholism") #check pathway names VERY carefully

```


Future work:
To pare down the number of genes to consider from GSEA results, we can examine the leading edge subset, which contribute the most to an enrichment signal.




### Volcano plotting specific orthologs
Using a combination of the annotated volcano plot from earlier and custom gsea ortholog lookup method.

```{r}
library(hrbrthemes)
#conversion
s1 = c("BRCA1","BRCA2","PARP1")
o1 = lookup[lookup$human_symbol %in% s1, c(5,9,12)]
o1 = o1[nchar(o1$zebrafish_ensembl_gene) == 18, ]


#S vs WT
d1 = S_vs_WT_d[S_vs_WT_d$name %in% o1$zebrafish_ensembl_gene, ]
ggplot(S_vs_WT_d, aes(x = log2FoldChange, y = -log10(padj), label=name)) + geom_point(alpha = 0.5, color = "dodgerblue") + labs(title = "Volcano, CCSER1_S vs WT") + geom_point(data = d1, aes(x = log2FoldChange, y = -log10(padj)), color="black") + geom_text_repel(data = d1, size = 3) + theme_ipsum()

m1 = merge(o1, d1, by.x = 2, by.y = 7)
ggplot(m1, aes(x = log2FoldChange, y = -log10(padj), label=zebrafish_symbol)) + geom_point(color = "black") + labs(title = "Volcano, CCSER1_S vs WT") + geom_text_repel(data = m1, size = 3) + theme_ipsum()

#M vs WT
d2 = M_vs_WT_d[M_vs_WT_d$name %in% o1$zebrafish_ensembl_gene, ]
ggplot(M_vs_WT_d, aes(x = log2FoldChange, y = -log10(padj), label=name)) + geom_point(alpha = 0.5, color = "seagreen") + labs(title = "Volcano, CCSER1_M vs WT") + geom_point(data = d2, aes(x = log2FoldChange, y = -log10(padj)), color="black") + geom_text_repel(data = d2, size = 3) + theme_ipsum()

m2 = merge(o1, d2, by.x = 2, by.y = 7)
ggplot(m2, aes(x = log2FoldChange, y = -log10(padj), label=zebrafish_symbol)) + geom_point(color = "black") + labs(title = "Volcano, CCSER1_M vs WT") + geom_text_repel(data = m2, size = 3) + theme_ipsum()

#M vs S
d3 = M_vs_S_d[M_vs_S_d$name %in% o1$zebrafish_ensembl_gene, ]
ggplot(M_vs_S_d, aes(x = log2FoldChange, y = -log10(padj), label=name)) + geom_point(alpha = 0.5, color = "firebrick") + labs(title = "Volcano, CCSER1_M vs CCSER1_S") + geom_point(data = d3, aes(x = log2FoldChange, y = -log10(padj)), color="black") + geom_text_repel(data = d3, size = 3) + theme_ipsum()

m3 = merge(o1, d3, by.x = 2, by.y = 7)
ggplot(m3, aes(x = log2FoldChange, y = -log10(padj), label=zebrafish_symbol)) + geom_point(color = "black") + labs(title = "Volcano, CCSER1_M vs CCSER1_S") + geom_text_repel(data = m3, size = 3) + theme_ipsum()


```

```{r}
s1 = c("ATR","ATM")
o1 = lookup[lookup$human_symbol %in% s1, c(5,9,12)]
o1 = o1[nchar(o1$zebrafish_ensembl_gene) == 18, ]

#S vs WT
d1 = S_vs_WT_d[S_vs_WT_d$name %in% o1$zebrafish_ensembl_gene, ]
ggplot(S_vs_WT_d, aes(x = log2FoldChange, y = -log10(padj), label=name)) + geom_point(alpha = 0.5, color = "dodgerblue") + labs(title = "Volcano, CCSER1_S vs WT") + geom_point(data = d1, aes(x = log2FoldChange, y = -log10(padj)), color="black") + geom_text_repel(data = d1, size = 3) + theme_ipsum()

m1 = merge(o1, d1, by.x = 2, by.y = 7)
ggplot(m1, aes(x = log2FoldChange, y = -log10(padj), label=zebrafish_symbol)) + geom_point(color = "black") + labs(title = "Volcano, CCSER1_S vs WT") + geom_text_repel(data = m1, size = 3) + theme_ipsum()

#M vs WT
d2 = M_vs_WT_d[M_vs_WT_d$name %in% o1$zebrafish_ensembl_gene, ]
ggplot(M_vs_WT_d, aes(x = log2FoldChange, y = -log10(padj), label=name)) + geom_point(alpha = 0.5, color = "seagreen") + labs(title = "Volcano, CCSER1_M vs WT") + geom_point(data = d2, aes(x = log2FoldChange, y = -log10(padj)), color="black") + geom_text_repel(data = d2, size = 3) + theme_ipsum()

m2 = merge(o1, d2, by.x = 2, by.y = 7)
ggplot(m2, aes(x = log2FoldChange, y = -log10(padj), label=zebrafish_symbol)) + geom_point(color = "black") + labs(title = "Volcano, CCSER1_M vs WT") + geom_text_repel(data = m2, size = 3) + theme_ipsum()

#M vs S
d3 = M_vs_S_d[M_vs_S_d$name %in% o1$zebrafish_ensembl_gene, ]
ggplot(M_vs_S_d, aes(x = log2FoldChange, y = -log10(padj), label=name)) + geom_point(alpha = 0.5, color = "firebrick") + labs(title = "Volcano, CCSER1_M vs CCSER1_S") + geom_point(data = d3, aes(x = log2FoldChange, y = -log10(padj)), color="black") + geom_text_repel(data = d3, size = 3) + theme_ipsum()

m3 = merge(o1, d3, by.x = 2, by.y = 7)
ggplot(m3, aes(x = log2FoldChange, y = -log10(padj), label=zebrafish_symbol)) + geom_point(color = "black") + labs(title = "Volcano, CCSER1_M vs CCSER1_S") + geom_text_repel(data = m3, size = 3) + theme_ipsum()

```

```{r}
s1 = c("XRCC5","XRCC6") # aka Ku70/Ku80
o1 = lookup[lookup$human_symbol %in% s1, c(5,9,12)]
o1 = o1[nchar(o1$zebrafish_ensembl_gene) == 18, ]

#S vs WT
d1 = S_vs_WT_d[S_vs_WT_d$name %in% o1$zebrafish_ensembl_gene, ]
ggplot(S_vs_WT_d, aes(x = log2FoldChange, y = -log10(padj), label=name)) + geom_point(alpha = 0.5, color = "dodgerblue") + labs(title = "Volcano, CCSER1_S vs WT") + geom_point(data = d1, aes(x = log2FoldChange, y = -log10(padj)), color="black") + geom_text_repel(data = d1, size = 3) + theme_ipsum()

m1 = merge(o1, d1, by.x = 2, by.y = 7)
ggplot(m1, aes(x = log2FoldChange, y = -log10(padj), label=zebrafish_symbol)) + geom_point(color = "black") + labs(title = "Volcano, CCSER1_S vs WT") + geom_text_repel(data = m1, size = 3) + theme_ipsum()

#M vs WT
d2 = M_vs_WT_d[M_vs_WT_d$name %in% o1$zebrafish_ensembl_gene, ]
ggplot(M_vs_WT_d, aes(x = log2FoldChange, y = -log10(padj), label=name)) + geom_point(alpha = 0.5, color = "seagreen") + labs(title = "Volcano, CCSER1_M vs WT") + geom_point(data = d2, aes(x = log2FoldChange, y = -log10(padj)), color="black") + geom_text_repel(data = d2, size = 3) + theme_ipsum()

m2 = merge(o1, d2, by.x = 2, by.y = 7)
ggplot(m2, aes(x = log2FoldChange, y = -log10(padj), label=zebrafish_symbol)) + geom_point(color = "black") + labs(title = "Volcano, CCSER1_M vs WT") + geom_text_repel(data = m2, size = 3) + theme_ipsum()

#M vs S
d3 = M_vs_S_d[M_vs_S_d$name %in% o1$zebrafish_ensembl_gene, ]
ggplot(M_vs_S_d, aes(x = log2FoldChange, y = -log10(padj), label=name)) + geom_point(alpha = 0.5, color = "firebrick") + labs(title = "Volcano, CCSER1_M vs CCSER1_S") + geom_point(data = d3, aes(x = log2FoldChange, y = -log10(padj)), color="black") + geom_text_repel(data = d3, size = 3) + theme_ipsum()

m3 = merge(o1, d3, by.x = 2, by.y = 7)
ggplot(m3, aes(x = log2FoldChange, y = -log10(padj), label=zebrafish_symbol)) + geom_point(color = "black") + labs(title = "Volcano, CCSER1_M vs CCSER1_S") + geom_text_repel(data = m3, size = 3) + theme_ipsum()

```

```{r}
s1 = c("MDM2", "EGFR", "CDK4", "MYC")
o1 = lookup[lookup$human_symbol %in% s1, c(5,9,12)]
o1 = o1[nchar(o1$zebrafish_ensembl_gene) == 18, ]

#S vs WT
d1 = S_vs_WT_d[S_vs_WT_d$name %in% o1$zebrafish_ensembl_gene, ]
ggplot(S_vs_WT_d, aes(x = log2FoldChange, y = -log10(padj), label=name)) + geom_point(alpha = 0.5, color = "dodgerblue") + labs(title = "Volcano, CCSER1_S vs WT") + geom_point(data = d1, aes(x = log2FoldChange, y = -log10(padj)), color="black") + geom_text_repel(data = d1, size = 3) + theme_ipsum()

m1 = merge(o1, d1, by.x = 2, by.y = 7)
ggplot(m1, aes(x = log2FoldChange, y = -log10(padj), label=zebrafish_symbol)) + geom_point(color = "black") + labs(title = "Volcano, CCSER1_S vs WT") + geom_text_repel(data = m1, size = 3) + theme_ipsum()

#M vs WT
d2 = M_vs_WT_d[M_vs_WT_d$name %in% o1$zebrafish_ensembl_gene, ]
ggplot(M_vs_WT_d, aes(x = log2FoldChange, y = -log10(padj), label=name)) + geom_point(alpha = 0.5, color = "seagreen") + labs(title = "Volcano, CCSER1_M vs WT") + geom_point(data = d2, aes(x = log2FoldChange, y = -log10(padj)), color="black") + geom_text_repel(data = d2, size = 3) + theme_ipsum()

m2 = merge(o1, d2, by.x = 2, by.y = 7)
ggplot(m2, aes(x = log2FoldChange, y = -log10(padj), label=zebrafish_symbol)) + geom_point(color = "black") + labs(title = "Volcano, CCSER1_M vs WT") + geom_text_repel(data = m2, size = 3) + theme_ipsum()

#M vs S
d3 = M_vs_S_d[M_vs_S_d$name %in% o1$zebrafish_ensembl_gene, ]
ggplot(M_vs_S_d, aes(x = log2FoldChange, y = -log10(padj), label=name)) + geom_point(alpha = 0.5, color = "firebrick") + labs(title = "Volcano, CCSER1_M vs CCSER1_S") + geom_point(data = d3, aes(x = log2FoldChange, y = -log10(padj)), color="black") + geom_text_repel(data = d3, size = 3) + theme_ipsum()

m3 = merge(o1, d3, by.x = 2, by.y = 7)
ggplot(m3, aes(x = log2FoldChange, y = -log10(padj), label=zebrafish_symbol)) + geom_point(color = "black") + labs(title = "Volcano, CCSER1_M vs CCSER1_S") + geom_text_repel(data = m3, size = 3) + theme_ipsum()

```




































































